var documenterSearchIndex = {"docs":
[{"location":"dynamic/","page":"Dynamic","title":"Dynamic","text":"These are some implemented methods for building dynamics","category":"page"},{"location":"dynamic/#Abstract-Dynamic-Definition","page":"Dynamic","title":"Abstract Dynamic Definition","text":"","category":"section"},{"location":"dynamic/","page":"Dynamic","title":"Dynamic","text":"Modules = [Base, \n        RigorousInvariantMeasures, \n        RigorousInvariantMeasures.DynamicDefinition]\nPages = [\"DynamicDefinition.jl\"]","category":"page"},{"location":"dynamic/#RigorousInvariantMeasures.DynamicDefinition.derivative-Tuple{Any, Any}","page":"Dynamic","title":"RigorousInvariantMeasures.DynamicDefinition.derivative","text":"derivative(n, f, x)\n\nNth derivative of a function (or a dynamic)\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#RigorousInvariantMeasures.DynamicDefinition.distortion-Tuple{Any, Any}","page":"Dynamic","title":"RigorousInvariantMeasures.DynamicDefinition.distortion","text":"distortion of a function (or a dynamic), i.e., |f′′ / f′^2|\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#RigorousInvariantMeasures.DynamicDefinition.endpoints-Tuple{Dynamic}","page":"Dynamic","title":"RigorousInvariantMeasures.DynamicDefinition.endpoints","text":"endpoints(S::Dynamic)\n\nEndpoints of the branches, in increasing order (returned as a vector of intervals)\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#RigorousInvariantMeasures.DynamicDefinition.expansivity","page":"Dynamic","title":"RigorousInvariantMeasures.DynamicDefinition.expansivity","text":"Maximum of |1/T'|\n\n\n\n\n\n","category":"function"},{"location":"dynamic/#RigorousInvariantMeasures.DynamicDefinition.max_distortion","page":"Dynamic","title":"RigorousInvariantMeasures.DynamicDefinition.max_distortion","text":"Maximum of distortion(D, x) = |T''| / (T')^2, over all branches\n\n\n\n\n\n","category":"function"},{"location":"dynamic/#RigorousInvariantMeasures.DynamicDefinition.orientation","page":"Dynamic","title":"RigorousInvariantMeasures.DynamicDefinition.orientation","text":"orientation(D, k)\n\nOrientation of branch k: 1. for increasing, -1. for decreasing\n\n\n\n\n\n","category":"function"},{"location":"dynamic/#RigorousInvariantMeasures.DynamicDefinition.preim","page":"Dynamic","title":"RigorousInvariantMeasures.DynamicDefinition.preim","text":"preim(S::Dynamic, k, y, ϵ)\n\nComputes the preim of y in branch k of a dynamic, with accuracy ϵ\n\n\n\n\n\n","category":"function"},{"location":"dynamic/#Piecewise-Map-Definition","page":"Dynamic","title":"Piecewise-Map Definition","text":"","category":"section"},{"location":"dynamic/","page":"Dynamic","title":"Dynamic","text":"Modules = [Base, \n        RigorousInvariantMeasures, \n        RigorousInvariantMeasures.DynamicDefinition,\n        RigorousInvariantMeasures.PwDynamicDefinition]\nPages = [\"PwDynamicDefinition.jl\"]","category":"page"},{"location":"dynamic/#RigorousInvariantMeasures.PwDynamicDefinition.PwMap","page":"Dynamic","title":"RigorousInvariantMeasures.PwDynamicDefinition.PwMap","text":"Dynamic based on a piecewise monotonic map.\n\nThe map is defined as T(x) = Tsk if x ∈ [endpoints[k], endpoints[k+1]).\n\ny_endpoints (kx2 matrix) contains the result of applying Ts to the endpoints of each interval. These can be filled in automatically from endpoints, but sometimes they are known to higher accuracy, for instance for x -> mod(3x, 1) we know that it is full-branch exactly. It is assumed that the map will send its domain hull(endpoints[begin],endpoints[end]) into itself.\n\nthe array branches is guaranteed to satisfy branches[i].X[end]==branches[i+1].X[begin]\n\n\n\n\n\n","category":"type"},{"location":"dynamic/#RigorousInvariantMeasures.PwDynamicDefinition.PwMap-Tuple{TaylorSeries.Taylor1}","page":"Dynamic","title":"RigorousInvariantMeasures.PwDynamicDefinition.PwMap","text":"Function call, and Taylor expansion, of a PwMap. Note that this ignores discontinuities; users are free to shoot themselves in the foot and call this on a non-smooth piecewise map. No better solutions for now.\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#RigorousInvariantMeasures.DynamicDefinition.branch-Tuple{PwMap, Any}","page":"Dynamic","title":"RigorousInvariantMeasures.DynamicDefinition.branch","text":"function that evaluates the k-th branch of a dynamic on a point x \t(assuming it's in its domain, otherwise ∅)\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#RigorousInvariantMeasures.DynamicDefinition.distortion-Tuple{RigorousInvariantMeasures.PwDynamicDefinition.Branch}","page":"Dynamic","title":"RigorousInvariantMeasures.DynamicDefinition.distortion","text":"Return the distortion function of a branch, i.e., |f′′ / f′^2|\n\n\n\n\n\n","category":"method"},{"location":"dynamic/#RigorousInvariantMeasures.DynamicDefinition.expansivity-2","page":"Dynamic","title":"RigorousInvariantMeasures.DynamicDefinition.expansivity","text":"expansivity(D::PwMap; tol=1e-3)\n\nCompute a rigorous bound for the expansivity of a PwMap\n\n\n\n\n\n","category":"function"},{"location":"dynamic/#RigorousInvariantMeasures.DynamicDefinition.max_distortion-2","page":"Dynamic","title":"RigorousInvariantMeasures.DynamicDefinition.max_distortion","text":"max_distortion(D::PwMap; tol=1e-3)\n\nCompute a rigorous bound for the distortion of a PwMap\n\nExample\n\njulia> using RigorousInvariantMeasures;\n\njulia> D0 = mod1_dynamic(x->2*x+0.5*x*(1-x), full_branch = true)\nPiecewise-defined dynamic with 2 branches\n\njulia> max_distortion(D0)\n[0.444268, 0.444445]\n\n\n\n\n\n","category":"function"},{"location":"dynamic/#RigorousInvariantMeasures.PwDynamicDefinition.bound_branch_distortion","page":"Dynamic","title":"RigorousInvariantMeasures.PwDynamicDefinition.bound_branch_distortion","text":"bound_branch_distortion(br::Branch; tol = 0.01)\n\nCompute a rigorous bound for the distortion of a branch on an interval I, defaults to the domain of the branch\n\n\n\n\n\n","category":"function"},{"location":"dynamic/#RigorousInvariantMeasures.PwDynamicDefinition.branch_expansivity","page":"Dynamic","title":"RigorousInvariantMeasures.PwDynamicDefinition.branch_expansivity","text":"branch_expansivity(br::Branch; tol = 0.01)\n\nCompute a rigorous bound for the expansivity of a branch\n\n\n\n\n\n","category":"function"},{"location":"dynamic/#RigorousInvariantMeasures.PwDynamicDefinition.restrict-Tuple{Any, Any}","page":"Dynamic","title":"RigorousInvariantMeasures.PwDynamicDefinition.restrict","text":"Intersect an Interval or TaylorSeries with I\n\n\n\n\n\n","category":"method"},{"location":"implementingnewbasis/#Implementing-a-new-basis","page":"Implementing a new basis","title":"Implementing a new basis","text":"","category":"section"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"In the file [BasisDefinition.jl] are declared the necessary methods  for the implementation of a new basis to work with the coarse-fine framework.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"The new basis type has to be defined as a subtype of the abstract type Basis.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"struct NewBasis <: Basis\n    # base specific code\nend","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"If possible, implement some utility constructors like  NewBasis(n) to initialize a basis of size n.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"To compute the operator through the generic assembler we implement a NewBasisDual <: Dual object that contains the data  necessary to compute the raw data necessary  to compute the entries of the operator, e.g., in the Ulam basis case, it contains three objects. One is a vector of preimages, which contains  all the preimages T_i^-1(x_j) of the elements of the partition  through the different branches T_i of the map, a second vector that contains the labels associated to these points, i.e., j. The layout is like this: $ [T1^{-1}(x1) \\ldots T1^{-1}(xn) T2^{-1}(x1) \\ldots ] $ $ [1 \\ldots n 1 \\ldots] $","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"In the case of the Hat basis, there is a third vector  that contains the derivative at the preimages.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"Now it is necessary to define an iterator on the Dual object, by defining  Base.iterate(dual::NewBasisDual, state = 1). This iterator returns the data necessary for the computation; in the case of the Ulam basis, it returns the label and the preimages of the endpoints  of one connected component of the preimage of an interval.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"We take now the elements returned by the iteration  on NewBasisDual and for each one of them we define  construct an object of type ProjectDualElement. This object contains information on which elements of the basis we need to compute corresponding to the dual element, computed through the BasisDefinition.nonzero_on function. In the Ulam case, it computes which intervals have nonempty intersection with the interval defined in  the dual element.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"Now, we need to define an iterator on the ProjectDualElement object that for all indexes associated to the dual element computes the  value of the coefficient of the operator.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"Resuming:","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"define a NewBasis structure\ndefine a NewDual structure and the iterator on it\ndefine a BasisDefinition.nonzero_on function which allows the construction of ProjectDualElement objects\ndefine the iterator on ProjectDualElementthat returns ","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"the coefficients","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"To allow the coarse-fine method to work out of the box, we need to implement different functions that return bound for the various constants. A comprehensive list is contained in the file [BasisDefinition.jl].","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"The first thing we need to define are the norm types that correspond to our approximation scheme.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"struct StrongNormNewBasis <: NormKind end\nstruct WeakNormNewBasis <: NormKind end","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"They must be specialized to our new basis, by first importing BasisDefinition and then specializing them.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"import BasisDefinition\n\nBasisDefinition.strong_norm(B::NewBasis) = StrongNormNewBasis\nBasisDefinition.weak_projection_error(B::NewBasis)","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"The needed constants and functions are listed there. If not defined, the compiler will call the most  general version that applies, the one in BasisDefinition, that throws an error.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"In principle, it is possible to define a new basis by  starting with only the struct, running the code and looking at the error codes julia is throwing, that correspond to the non implemented functions.","category":"page"},{"location":"api/#Library","page":"API","title":"Library","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = RigorousInvariantMeasures","category":"page"},{"location":"api/#Contractors","page":"API","title":"Contractors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"These are interval contractors implemented here; in the future they may be substituted by established libraries, as IntervalRootFinding.jl","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Base, \n            RigorousInvariantMeasures, \n            RigorousInvariantMeasures.Contractors]\nPages = [\"Contractors.jl\"]","category":"page"},{"location":"api/#RigorousInvariantMeasures.Contractors.nthpreimage!-Tuple{Any, Any, Any}","page":"API","title":"RigorousInvariantMeasures.Contractors.nthpreimage!","text":"Newer version of the 'shooting method' to compute the kth preimage of a point (or interval y) fs contains k functions, X contains their domains. This computes a solution of fk(f{k-1}( ...  f1(x) ... )) = y. Overwrites X with [x f1(x) f2(f1(x)) ... f{k-1}(...)], so the true solution is X[1].\n\nTries to avoid allocations and stuff.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.Contractors.root-Tuple{Any, Any}","page":"API","title":"RigorousInvariantMeasures.Contractors.root","text":"Compute a single root with (possibly multivariate) interval Newton\n\nx must be an Interval (univariate) or IntervalBox (multivariate)\n\nStops when the interval reaches a fixed point, when the diameter is smaller than ε, or when max_iter iterations are reached (with an error)\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.Contractors.unique_increasing-Tuple{Interval, Interval}","page":"API","title":"RigorousInvariantMeasures.Contractors.unique_increasing","text":"unique_increasing(a, b)\n\nGiven intervals a, b, returns true if a < b, false if b < a, and raises an error if it is not uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.Contractors.unique_sign-Tuple{Any}","page":"API","title":"RigorousInvariantMeasures.Contractors.unique_sign","text":"unique_sign(x)\n\nSign of an interval, but throws an error if it is not unique. Used by various functions to compute orientations\n\n\n\n\n\n","category":"method"},{"location":"api/#Preimages","page":"API","title":"Preimages","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Optimized methods to compute preimages of 1 dimensional maps.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [Base, \n            RigorousInvariantMeasures, \n            RigorousInvariantMeasures.DynamicDefinition]\nPages = [\"preimages.jl\"]","category":"page"},{"location":"api/#RigorousInvariantMeasures.ComposedDynamic","page":"API","title":"RigorousInvariantMeasures.ComposedDynamic","text":"Composed map D1 ∘ D2 ∘ D3. We store with [D1, D2, D3] in this order.\n\nWe overwrite ∘ in base, so one can simply write D1 ∘ D2 or ∘(D1, D2, D3) to construct them.\n\n\n\n\n\n","category":"type"},{"location":"api/#RigorousInvariantMeasures.DynamicDefinition.domain-Tuple{RigorousInvariantMeasures.ComposedDynamic}","page":"API","title":"RigorousInvariantMeasures.DynamicDefinition.domain","text":"Utility function to return the domain of a dynamic\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.first_overlapping-Tuple{Any, Any}","page":"API","title":"RigorousInvariantMeasures.first_overlapping","text":"first_overlapping(y, a)\n\nSmallest possible i such that a is in the semi-open interval [y[i], y[i+1]).\n\nThis should work properly even if a, y are intervals; in this case it returns the smallest possible value of i over all possible \"assignments\" of a, y inside those intervals. Assumes y is sorted, i.e., map(y, x->Interval(x).lo) and map(y, x->Interval(x).hi) are sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.last_overlapping-Tuple{Any, Any}","page":"API","title":"RigorousInvariantMeasures.last_overlapping","text":"last_overlapping(y, a)\n\nLargest possible j such that a-ε is in the semi-open interval [y[j], y[j+1]).\n\nThis should work properly even if a, y are intervals; in this case it returns the largest possible value of i over all possible \"assignments\" of a, y inside those intervals. Assumes y is sorted, i.e., map(y, x->Interval(x).lo) and map(y, x->Interval(x).hi) are sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.preimages","page":"API","title":"RigorousInvariantMeasures.preimages","text":"preimages(y, D::Dynamic, ylabel = 1:length(y), ϵ = 0.0; progress = true)\n\nConstruct preimages of an increasing array y under a dynamic, propagating additional labels `ylabel`\n\n\n\n\n\n","category":"function"},{"location":"api/#RigorousInvariantMeasures.preimages-2","page":"API","title":"RigorousInvariantMeasures.preimages","text":"preimages(y, br::Branch, ylabel = 1:length(y); ϵ, max_iter)\n\nConstruct preimages of an increasing array y under a monotonic branch defined on X = (a, b), propagating additional labels ylabel\n\nConstruct preimages of an increasing array y under a monotonic branch br defined on X = (a, b), propagating additional labels ylabel\n\nIt is assumed that it cannot happen that f(x)  y1.\n\nExtended help\n\nThe sequence y subdivides the y-axis into semi-open intervals [y[l], y[l+1]); each of them is identified by the label ylabel[l]. We construct an increasing sequence  x that splits X (in the x-axis) into semi-open intervals, each of them with f([x[k], x[k+1]) ⊂ [y[l], y[l+1]) for a certain l.  We set xlabel[k] = ylabel[l], and return the pair (x, xlabel).\n\nIt is assumed that it cannot happen that f(x) < y[1].\n\nIn the simplest case where D is full-branch, the points in x are preimages of the points in y, but in the general case they can also include D.endpoints: in general, there may be a certain number of points in y that have no preimage at the beginning and the end of the sequence, because  they fall out of the range R = [f(a), f(b)]. In the worst case, no point has a preimage, because y[i] < R < y[i+1] for some  i (or vice versa with orientations), and in this case we just return the 1-element vectors x = [branch.X[1]] and xlabel = [i].\n\nx[begin] always coincides with branch.X[1], while branch.X[2] is \"the point after x[end]\", and is not stored explicitly in x, for easier composing. In this way x and xlabel have the same length.\n\nThis function fills the array by using a bisection strategy to save computations: if y ∈ [a,b], then f⁻¹(y) ∈ f⁻¹(a),f⁻¹(b). So we can fill v by filling in first entries v[k+1] with higher dyadic valuation of k.\n\nFor a dynamic with multiple branches, preimages(y, D) is simply the concatenation of x, xlabel for b in all branches. These values still form an increasing sequence that splits X into intervals, each of which is mapped into a different semi-open interval [y[k], y[k+1]).\n\nExample\n\njulia> using RigorousInvariantMeasures\n\njulia> D = mod1_dynamic(x->2x)\nPiecewise-defined dynamic with 2 branches\n\njulia> RigorousInvariantMeasures.preimages(0:0.1:1, D.branches[1]; ϵ = 10^(-15), max_iter = 100)\n(Interval{Float64}[[0, 0], [0.05, 0.0500001], [0.1, 0.100001], [0.149999, 0.15], [0.2, 0.200001], [0.25, 0.25], [0.299999, 0.3], [0.349999, 0.35], [0.4, 0.400001], [0.45, 0.450001]], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n\n\n\n\n","category":"function"},{"location":"api/#RigorousInvariantMeasures.preimages_and_derivatives","page":"API","title":"RigorousInvariantMeasures.preimages_and_derivatives","text":"preimages_and_derivatives(y, br::Branch, ylabel = 1:length(y), ϵ = 0.0)\n\nCompute preimages of D and the derivatives f'(x) in each point.\n\nReturns: x, xlabel, x′\n\nAssumes that the dynamic is full-branch, because otherwise things may compose the wrong way. This is not restrictive because we'll need it only for the Hat assembler (at the moment)\n\nWe combine them in a single function because there are avenues to optimize by recycling some computations (not completely exploited for now)\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"basis.md\", \"api.md\", \"dynamic.md\"]\nModules = [RigorousInvariantMeasures]\nOrder = [:type, :function]","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"We present some of the basis already implemented in the package","category":"page"},{"location":"basis/#Abstract-basis","page":"Basis","title":"Abstract basis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Modules = [Base, \n        RigorousInvariantMeasures, \n        RigorousInvariantMeasures.BasisDefinition]\nPages = [\"BasisDefinition.jl\"]","category":"page"},{"location":"basis/#RigorousInvariantMeasures.Dual","page":"Basis","title":"RigorousInvariantMeasures.Dual","text":"Replacement of DualComposedWithDynamic.\n\n\n\n\n\n","category":"type"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.AverageZero","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.AverageZero","text":"AverageZero{B<:Basis}\n\nYield a basis of the space of average zero vectors\n\n\n\n\n\n","category":"type"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.aux_normalized_projection_error-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.aux_normalized_projection_error","text":"aux_normalized_projection_error(B::Basis)\n\nReturn a constant Eh (typically scales as h ~ 1/n) such that  |||P_h f|||\\leq |||f|||+ Eh * ||f||_s Must be rounded up correctly!\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.aux_weak_bound-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.aux_weak_bound","text":"aux_weak_bound(B::Basis)\n\nReturn a constant M₂ such that for a vector v  Uₕ  |||v|||\\leq M_2||v|| Must be rounded up correctly!\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.bound_linalg_norm_L1_from_weak-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.bound_linalg_norm_L1_from_weak","text":"bound_linalg_norm_L1_from_weak(B::Basis)\n\nReturn a constant A such that for a vector v  Uₕ  ||v||_1\\leq A||v|| Must be rounded up correctly!\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.bound_linalg_norm_L∞_from_weak-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.bound_linalg_norm_L∞_from_weak","text":"bound_linalg_norm_L∞_from_weak(B::Basis)\n\nReturn a constant A such that for a vector v  Uₕ  ||v||_\\infty \\leq A||v|| Must be rounded up correctly!\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.bound_weak_norm_abstract","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.bound_weak_norm_abstract","text":"bound_weak_norm_abstract(B::Basis, D=nothing; dfly_coefficients=nothing)\n\nReturns an a priori bound on the weak norm of the abstract operator L\n\n\n\n\n\n","category":"function"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.bound_weak_norm_from_linalg_norm-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.bound_weak_norm_from_linalg_norm","text":"bound_weak_norm_from_linalg_norm(B::Basis)\n\nReturn constants W₁, W₂ such that for a vector v  Uₕ  ||v||\\leq W_1||v||_1+W_2||v||_{\\infty} Must be rounded up correctly!\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.evaluate-Tuple{Basis, Any, Any}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.evaluate","text":"evaluate(B::Basis, i, x)\n\nEvaluate the i-th basis element at x\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.evaluate_integral-Tuple{Basis, Any}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.evaluate_integral","text":"evaluate_integral(B::Basis, i; T = Float64)\n\nValue of the integral on [0,1] of the i-th basis element\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.integral-Tuple{Basis, Any}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.integral","text":"integral(B::Basis, v; T = Float64)\n\nReturn the integral of the function with coefficients v in the basis B \n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.integral_covector-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.integral_covector","text":"integral_covector(B::Basis)\n\nReturn a covector that represents the integral in the basis B\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.invariant_measure_strong_norm_bound-Tuple{Basis, Dynamic}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.invariant_measure_strong_norm_bound","text":"invariant_measure_strong_norm_bound(B::Basis, D::Dynamic)\n\nBounds u_s, where u is the invariant measure normalized with  i(u)=1.\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.is_integral_preserving-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.is_integral_preserving","text":"is_integral_preserving(B::Basis)\n\nIntegral-preserving discretizations may specialize this to \"true\"\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.is_refinement-Tuple{Basis, Basis}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.is_refinement","text":"is_refinement(Bfine::Basis, Bcoarse::Basis)\n\nCheck if Bfine is a refinement of Bcoarse\n\nExample\n\njulia> using RigorousInvariantMeasures\n\njulia> B = Ulam(1024)\nUlam{LinRange{Float64, Int64}}(LinRange{Float64}(0.0, 1.0, 1025))\n\njulia> Bfine = Ulam(2048)\nUlam{LinRange{Float64, Int64}}(LinRange{Float64}(0.0, 1.0, 2049))\n\njulia> is_refinement(Bfine, B)\ntrue\n\njulia> Bfine = Ulam(2049)\nUlam{LinRange{Float64, Int64}}(LinRange{Float64}(0.0, 1.0, 2050))\n\njulia> is_refinement(Bfine, B)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.one_vector-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.one_vector","text":"one_vector(B::Basis)\n\nVector that represents the function 1 in the basis B\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.strong_norm-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.strong_norm","text":"strong_norm(B::Basis)\n\nReturn the type of the strong norm of the basis\n\nExample\n\njulia> using RigorousInvariantMeasures\n\njulia> B = Ulam(1024)\nUlam{LinRange{Float64, Int64}}(LinRange{Float64}(0.0, 1.0, 1025))\n\njulia> strong_norm(B)\nTotalVariation\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.strong_weak_bound-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.strong_weak_bound","text":"strong_weak_bound(B::Basis)\n\nReturn a constant M₁n such that for a vector v  Uₕ  ||v||_s\\leq M1n*||v|| Must be rounded up correctly!\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.weak_by_strong_and_aux_bound-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.weak_by_strong_and_aux_bound","text":"Return constants ``S₁, S₂`` such that for a vector ``v ∈ Uₕ`` \n```||v||\\leq S_1||v||_s+S_2|||v|||```\n\nMust be rounded up correctly!\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.weak_norm-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.weak_norm","text":"weak_norm(B::Basis)\n\nReturn the type of the weak norm of the basis\n\nExample\n\njulia> using RigorousInvariantMeasures\n\njulia> B = Ulam(1024)\nUlam{LinRange{Float64, Int64}}(LinRange{Float64}(0.0, 1.0, 1025))\n\njulia> weak_norm(B)\nL1\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.weak_projection_error-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.weak_projection_error","text":"weak_projection_error(B::Basis)\n\nReturn a constant Kh (typically scales as h ~ 1/n) such that  ||P_h f-f||\\leq Kh ||f||_s Must be rounded up correctly! This function is not exported explictly but is used in all the estimates.\n\nExample\n\n```jldoctest julia> using RigorousInvariantMeasures;\n\njulia> B = Ulam(1024) Ulam{LinRange{Float64, Int64}}(range(0.0, stop=1.0, length=1025))\n\njulia> RigorousInvariantMeasures.BasisDefinition.weakprojectionerror(B)\n\n0.00048828125 ````\n\n\n\n\n\n","category":"method"},{"location":"basis/#The-Ulam-basis","page":"Basis","title":"The Ulam basis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Modules = [Base, \n            RigorousInvariantMeasures, \n            RigorousInvariantMeasures.BasisDefinition]\nPages = [\"UlamBasis.jl\"]","category":"page"},{"location":"basis/#RigorousInvariantMeasures.Ulam","page":"Basis","title":"RigorousInvariantMeasures.Ulam","text":"Ulam\n\nUlam basis on [0,1] associated to the partition p = x_0 = 0 x_1 ldots x_n=1\n\n\n\n\n\n","category":"type"},{"location":"basis/#RigorousInvariantMeasures.Ulam-Tuple{Integer}","page":"Basis","title":"RigorousInvariantMeasures.Ulam","text":"Ulam(n::Integer)\n\nEquispaced Ulam basis on [0,1] of size n\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.getindex-Tuple{Ulam, Int64}","page":"Basis","title":"Base.getindex","text":"Base.getindex(B::Ulam, i::Int)\n\nReturns the i-th element of the Ulam basis as a function.\n\nExample\n\njulia> using RigorousInvariantMeasures\n\njulia> B = Ulam(16)\nUlam{LinRange{Float64, Int64}}(LinRange{Float64}(0.0, 1.0, 17))\n\njulia> B[1](1/32)\n1\n\njulia> B[2](1/32)\n0\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.iterate-Union{Tuple{RigorousInvariantMeasures.BasisDefinition.AverageZero{Ulam{T}}}, Tuple{T}, Tuple{RigorousInvariantMeasures.BasisDefinition.AverageZero{Ulam{T}}, Any}} where T","page":"Basis","title":"Base.iterate","text":"iterate(S::AverageZero{Ulam{T}}, state = 1) where{T}\n\nReturn the elements of the basis of average 0 functions in the Ulam  Basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.iterate-Union{Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{BT, DT}}, Tuple{DT}, Tuple{BT}, Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{BT, DT}, Any}} where {BT<:Ulam, DT}","page":"Basis","title":"Base.iterate","text":"Given a preimage of an interval I_i, this iterator returns its relative intersection with all the elements of the Ulam basis that have nonzero intersection with it\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.length-Tuple{Ulam}","page":"Basis","title":"Base.length","text":"Base.length(B::Ulam)\n\nReturns the size of the Ulam basis (the size of the underlying vector -1)\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.length-Union{Tuple{RigorousInvariantMeasures.BasisDefinition.AverageZero{Ulam{T}}}, Tuple{T}} where T","page":"Basis","title":"Base.length","text":"Base.length(S::AverageZero{Ulam})\n\nReturn the size of the Average Zero space\n\n\n\n\n\n","category":"method"},{"location":"basis/#RecipesBase.apply_recipe","page":"Basis","title":"RecipesBase.apply_recipe","text":"Displays error on a function in the Ulam basis\n\nThe w argument is unused, but kept for compatibility with other functions for different bases\n\n\n\n\n\n","category":"function"},{"location":"basis/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, Ulam, AbstractVector}","page":"Basis","title":"RecipesBase.apply_recipe","text":"Plots a function in the Ulam basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.nonzero_on-Tuple{Ulam, Any}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.nonzero_on","text":"nonzero_on(B::Ulam, (a, b))\n\nReturns the indices of the elements of the Ulam basis that intersect with the interval y We do not assume an order of a and b; this should not matter unless the preimages are computed with very low accuracy. We assume, though, that y comes from the (possibly inexact) numerical approximation of an interval in 01, i.e., we restrict to y cap 01\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.relative_measure-Tuple{Tuple{Interval, Interval}, Tuple{Interval, Interval}}","page":"Basis","title":"RigorousInvariantMeasures.relative_measure","text":"relative_measure((a,b)::Tuple{<:Interval,<:Interval}, (c,d)::Tuple{<:Interval,<:Interval})\n\nRelative measure of the intersection of (a,b) wrt the whole interval (c,d) Assumes that a,b and c,d are sorted correctly\n\n\n\n\n\n","category":"method"},{"location":"basis/#The-hat-basis-on-S1","page":"Basis","title":"The hat basis on S^1","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Modules = [Base, \n            RigorousInvariantMeasures, \n            RigorousInvariantMeasures.BasisDefinition]\nPages = [\"HatBasis.jl\"]","category":"page"},{"location":"basis/#RigorousInvariantMeasures.Hat","page":"Basis","title":"RigorousInvariantMeasures.Hat","text":"Hat\n\nThis type represents a Hat basis on S^1. It contains a vector with the midpoints of the hats.\n\n\n\n\n\n","category":"type"},{"location":"basis/#RigorousInvariantMeasures.Hat-Tuple{Integer}","page":"Basis","title":"RigorousInvariantMeasures.Hat","text":"Hat(n::Integer)\n\nThis constructs a Hat basis on S^1 on equispaced points\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.HatFunction","page":"Basis","title":"RigorousInvariantMeasures.HatFunction","text":"Hat function (on the reals)\n\nThis is a piecewise linear function such that: \tf(x) = 0 if x <= lo \tf(mi) = 1 \tf(hi)\n\n\n\n\n\n","category":"type"},{"location":"basis/#RigorousInvariantMeasures.HatFunctionOnTorus","page":"Basis","title":"RigorousInvariantMeasures.HatFunctionOnTorus","text":"HatFunctionOnTorus\n\nHat function (on the torus)\n\nThis is a piecewise linear function such that: \tf(x) = 0 if x <= lo \tf(mi) = 1 \tf(x) = 0 if x >= ho\n\n\n\n\n\n","category":"type"},{"location":"basis/#RigorousInvariantMeasures.IntervalOnTorus","page":"Basis","title":"RigorousInvariantMeasures.IntervalOnTorus","text":"IntervalOnTorus\n\nA separate type for intervals on the torus (mod 1) to \"remind\" us of the quotient\n\nThe interval is normalized in the constructor: the caller may assume that\n\n0 <= i.lo < 1\ni.hi < i.lo + 1 OR i==Interval(0,1)\n\n\n\n\n\n","category":"type"},{"location":"basis/#Base.getindex-Tuple{Hat, Int64}","page":"Basis","title":"Base.getindex","text":"Base.getindex(B::Hat, i::Int)\n\nMake so that B[j] returns a HatFunctionOnTorus with the j-th basis element\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.getindex-Tuple{HatNP, Int64}","page":"Basis","title":"Base.getindex","text":"Base.getindex(B::HatNP, i::Int)\n\nmakes so that B[j] returns a  HatFunction with the j-th basis element\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.iterate-Union{Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{T, DT}}, Tuple{DT}, Tuple{T}, Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{T, DT}, Any}} where {T<:Hat, DT}","page":"Basis","title":"Base.iterate","text":"Given a preimage y of a point x, this iterator returns \\phi_j(y)/T'(y)\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.iterate-Union{Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{T, DT}}, Tuple{DT}, Tuple{T}, Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{T, DT}, Any}} where {T<:HatNP, DT}","page":"Basis","title":"Base.iterate","text":"Given a preimage y of a point x, this iterator returns \\phi_j(y)/T'(y)\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.length-Union{Tuple{HatNP{T}}, Tuple{T}} where T","page":"Basis","title":"Base.length","text":"Base.length(B::HatNP)\n\nReturn the size of the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.length-Union{Tuple{Hat{T}}, Tuple{T}} where T","page":"Basis","title":"Base.length","text":"Base.length(B::Hat{T})\n\nReturn the size of the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, Hat, AbstractVector}","page":"Basis","title":"RecipesBase.apply_recipe","text":"Plots a function in the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, Hat, Number, Any}","page":"Basis","title":"RecipesBase.apply_recipe","text":"Displays error on a function in the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, HatNP, AbstractVector}","page":"Basis","title":"RecipesBase.apply_recipe","text":"Plots a function in the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, HatNP, Number, Any}","page":"Basis","title":"RecipesBase.apply_recipe","text":"Displays error on a function in the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.nonzero_on-Tuple{Hat, Any}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.nonzero_on","text":"BasisDefinition.nonzero_on(B::Hat, dual_element)\n\nReturn the range of indices of the elements of the basis whose support intersects with the given dual element (i.e., a pair (y, absT')). The range may end with length(B)+1; this must be interpreted \"mod length(B)\": it means that it intersects with the hat function peaked in 0 as well (think for instance y = 0.9999).\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.nonzero_on-Tuple{HatNP, Any}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.nonzero_on","text":"Return the range of indices of the elements of the basis whose support intersects with the given dual element (i.e., a pair (y, absT')). The range may end with length(B)+1; this must be interpreted \"mod length(B)\": it means that it intersects with the hat function peaked in 0 as well (think for instance y = 0.9999).\n\n\n\n\n\n","category":"method"},{"location":"basis/#The-hat-basis-on-[0,1]","page":"Basis","title":"The hat basis on 01","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Modules = [Base, \n            RigorousInvariantMeasures, \n            RigorousInvariantMeasures.BasisDefinition]\nPages = [\"NonPeriodicHatBasis.jl\"]","category":"page"},{"location":"basis/#The-C2-basis","page":"Basis","title":"The C2 basis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Modules = [Base, \n            RigorousInvariantMeasures, \n            RigorousInvariantMeasures.BasisDefinition,\n            RigorousInvariantMeasures.C2BasisDefinition]\nPages = [\"C2Basis.jl\"]","category":"page"},{"location":"basis/#RigorousInvariantMeasures.C2BasisDefinition.EquispacedPartitionInterval","page":"Basis","title":"RigorousInvariantMeasures.C2BasisDefinition.EquispacedPartitionInterval","text":"Equispaced partition of size n of [0,1]\n\n\n\n\n\n","category":"type"},{"location":"basis/#Base.iterate-Union{Tuple{RigorousInvariantMeasures.BasisDefinition.DualComposedWithDynamic{T, Dynamic}}, Tuple{T}, Tuple{RigorousInvariantMeasures.BasisDefinition.DualComposedWithDynamic{T, Dynamic}, Any}} where T<:C2Basis","page":"Basis","title":"Base.iterate","text":"Return (in an iterator) the pairs (i, (x, |T'(x)|)) where x is a preimage of p[i], which describe the \"dual\" L* evaluation(p[i])\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.iterate-Union{Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{T}}, Tuple{T}, Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{T}, Any}} where T<:C2Basis","page":"Basis","title":"Base.iterate","text":"Given a preimage y of a point x, this iterator returns \\phi_j(y)/T'(y)\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.length-Tuple{C2Basis}","page":"Basis","title":"Base.length","text":"Return the size of the C2 basisBase.length(S::AverageZero) = length(S.basis)-1\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.nonzero_on-Tuple{C2Basis, Any}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.nonzero_on","text":"Return the range of indices of the elements of the basis whose support intersects with the given dual element (i.e., a pair (y, absT', derder)).\n\n\n\n\n\n","category":"method"},{"location":"basis/#The-Chebyshev-basis","page":"Basis","title":"The Chebyshev basis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Modules = [Base, \n            RigorousInvariantMeasures, \n            RigorousInvariantMeasures.BasisDefinition]\nPages = [\"NewChebyshev.jl\"]","category":"page"},{"location":"basis/#Base.getindex-Tuple{Chebyshev, Int64}","page":"Basis","title":"Base.getindex","text":"Base.getindex(B::Chebyshev, i::Int)\n\nMake so that B[j] returns a HatFunctionOnTorus with the j-th basis element\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.length-Tuple{Chebyshev}","page":"Basis","title":"Base.length","text":"Return the size of the Chebyshev basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures._eval_T-Union{Tuple{T}, Tuple{Any, Array{T}}} where T","page":"Basis","title":"RigorousInvariantMeasures._eval_T","text":"_eval_T\n\nEval the Chebyshev polynomial up to degree n on an array of  points in [-1, 1].\n\nNot satisfactory, the intervals explode\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.eval_Clenshaw_BackwardFirst-Union{Tuple{T}, Tuple{S}, Tuple{Array{Interval{S}, 1}, Interval{T}}} where {S, T}","page":"Basis","title":"RigorousInvariantMeasures.eval_Clenshaw_BackwardFirst","text":"eval_Clenshaw_BackwardFirst\n\nEval a polynomial in Chebyshev basis, ClenshawBackward, using ball arithmetic Following Viviane Ledoux, Guillaume Moroz  \"Evaluation of Chebyshev polynomials on intervals andapplication to root finding\"\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.get_norm-Tuple{RigorousInvariantMeasures.NormCacherC1}","page":"Basis","title":"RigorousInvariantMeasures.get_norm","text":"Return the norm of the matrix the NormCacher is working on.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Some examples can be found at RigorousInvariantMeasures.jl/examples/","category":"page"},{"location":"userguide/#Userguide","page":"General usage","title":"Userguide","text":"","category":"section"},{"location":"userguide/","page":"General usage","title":"General usage","text":"The main objects involved in the approximation are the following:","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"A dynamic object\nA basis object ","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"julia> using RigorousInvariantMeasures\n\njulia> D0 = mod1_dynamic(x->4*x+0.5*x*(1-x), full_branch = true)\nPiecewise-defined dynamic with 4 branches\n\njulia> D = D0∘D0∘D0\nRigorousInvariantMeasures.ComposedDynamic((RigorousInvariantMeasures.ComposedDynamic((Piecewise-defined dynamic with 4 branches, Piecewise-defined dynamic with 4 branches), Piecewise-defined dynamic with 16 branches), Piecewise-defined dynamic with 4 branches), Piecewise-defined dynamic with 64 branches)\n\njulia> B = Hat(1024)\nHat{LinRange{Float64, Int64}}(LinRange{Float64}(0.0, 1.0, 1025))","category":"page"},{"location":"userguide/#Building-the-discretized-operator","page":"General usage","title":"Building the discretized operator","text":"","category":"section"},{"location":"userguide/","page":"General usage","title":"General usage","text":"Once a basis is chosen we call DiscretizedOperator to compute the discretized operator.","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"Remark that a discretized operator can be of two types:","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"IntegralPreservingDiscretizedOperator\nNonIntegralPreservingDiscretizedOperator","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"The type of the discretized operator is prescribed by the basis; while an integral preserving operator is stored simply as a matrix, a non integral preserving operator is stored as a triple (L e w); the operator L corresponds to the matrix, while e w are used to guarantee that the operator Q = L + e*w preserves the integral.","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"This is fundamental in our theory, since the rigorous estimate depends on the fact that the  discretized operator preserves the space of average 0 functions.","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"julia> Q = DiscretizedOperator(B, D);","category":"page"},{"location":"userguide/#Bounding-the-norms-of-the-discretized-operator","page":"General usage","title":"Bounding the norms of the discretized operator","text":"","category":"section"},{"location":"userguide/","page":"General usage","title":"General usage","text":"To compute our rigorous error bound we need to compute rigorously upper bounds for the norms of the discretized operator restricted  Q^k_U_0 to the space of average 0 functions.","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"This is done through the use of powernormbounds","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"julia> norms = powernormbounds(B, D; Q=Q);","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"This function infers the strong and weak norm from the basis and uses a priori  and a posteriori information to estimate these norms.","category":"page"},{"location":"userguide/#Computing-the-invariant-vector-and-the-rigorous-error","page":"General usage","title":"Computing the invariant vector and the rigorous error","text":"","category":"section"},{"location":"userguide/","page":"General usage","title":"General usage","text":"To compute the approximation and the error we use the functions  invariant_vector and distance_from_invariant.","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"Distance from invariant returns us an upper bound between  w and the density of the invariant a.c.i.m. with respect to the  weak norm of the basis.","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"julia> w = invariant_vector(B, Q);\n\njulia> error = distance_from_invariant(B, D, Q, w, norms);\n\njulia> error <= 0.0006\ntrue\n\njulia> weak_norm(B)\nLinf","category":"page"},{"location":"userguide/#Using-the-coarse-fine-estimates","page":"General usage","title":"Using the coarse-fine estimates","text":"","category":"section"},{"location":"userguide/","page":"General usage","title":"General usage","text":"We can use now the coarse fine bounds to bound the norm of the powers of a finer discretization.","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"The function finepowernormbounds uses the computed norms  from the coarse discretization, the coefficients of the Doeblin-Fortet-Lasota-Yorke inequality and a computed error bound on the norm of Q_f. ","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"We first define a finer basis and compute the operator","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"julia> B_fine = Hat(16384);\n\njulia> Q_fine = DiscretizedOperator(B_fine, D);","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"Then, we call the coarse fine routines","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"julia> normQ_fine = opnormbound(B_fine, weak_norm(B_fine), Q_fine)\n1.043367200577545\n\njulia> norms_fine = finepowernormbounds(B, B_fine, D, norms; normQ_fine=normQ_fine);\n\njulia> w_fine = invariant_vector(B_fine, Q_fine);\n     \njulia> error_fine = distance_from_invariant(B_fine, D, Q_fine, w_fine, norms_fine);\n\njulia> error_fine <= 8e-5\ntrue","category":"page"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"#RigorousInvariantMeasures.jl","page":"Home","title":"RigorousInvariantMeasures.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package which implements a implements a flexible scheme to approximate rigorously invariant measures of dynamical systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find useful this package, please cite the paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Galatolo S., Monge M., Nisoli I., Poloni F. A general framework for the rigorous computation of invariant densities and the coarse-fine strategy [arXiv:2212.05017]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Galatolo S., Nisoli I., An elementary approach to rigorous approximation of invariant measures SIAM J. Appl Dyn Sys.13 pp. 958-985 (2014)","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RigorousInvariantMeasures is licensed under the MIT license; see LICENSE for the full license text.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RigorousInvariantMeasures.jl is a registered package, and is simply installed by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add(\"RigorousInvariantMeasures\")","category":"page"}]
}
