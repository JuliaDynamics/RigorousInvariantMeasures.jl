var documenterSearchIndex = {"docs":
[{"location":"api/#Library","page":"API","title":"Library","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = RigorousInvariantMeasures","category":"page"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"basis.md\", \"api.md\"]\nModules = [RigorousInvariantMeasures]\nOrder = [:type, :function]","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"We present some of the basis already implemented in the package","category":"page"},{"location":"basis/#The-Ulam-basis","page":"Basis","title":"The Ulam basis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Module = [RigorousInvariantMeasures]\nPages = [\"Ulam.jl\"]","category":"page"},{"location":"basis/#The-hat-basis-on-S1","page":"Basis","title":"The hat basis on S^1","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Module = [RigorousInvariantMeasures]\nPages = [\"HatBasis.jl\"]","category":"page"},{"location":"basis/#The-hat-basis-on-[0,1]","page":"Basis","title":"The hat basis on 01","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Module = [RigorousInvariantMeasures]\nPages = [\"NonPeriodicHatBasis.jl\"]","category":"page"},{"location":"basis/#The-Chebyshev-basis","page":"Basis","title":"The Chebyshev basis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Module = [RigorousInvariantMeasures]\nPages = [\"Chebyshev.jl\"]","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Some examples can be found at RigorousInvariantMeasures.jl/examples/","category":"page"},{"location":"userguide/#Userguide","page":"User guide","title":"Userguide","text":"","category":"section"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The main objects involved in the approximation are the following:","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"A dynamic object\nA basis object ","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"julia> using RigorousInvariantMeasures\n\njulia> D0 = mod1_dynamic(x->4*x+0.5*x*(1-x), full_branch = true)\nPiecewise-defined dynamic with 4 branches\n\njulia> D = D0∘D0∘D0\nRigorousInvariantMeasures.ComposedDynamic((RigorousInvariantMeasures.ComposedDynamic((Piecewise-defined dynamic with 4 branches, Piecewise-defined dynamic with 4 branches), Piecewise-defined dynamic with 16 branches), Piecewise-defined dynamic with 4 branches), Piecewise-defined dynamic with 64 branches)\n\njulia> B = Hat(1024)\nHat{LinRange{Float64, Int64}}(range(0.0, stop=1.0, length=1025))","category":"page"},{"location":"userguide/#Building-the-discretized-operator","page":"User guide","title":"Building the discretized operator","text":"","category":"section"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Once a basis is chosen we call DiscretizedOperator to compute the discretized operator.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Remark that a discretized operator can be of two types:","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"IntegralPreservingDiscretizedOperator\nNonIntegralPreservingDiscretizedOperator","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The type of the discretized operator is prescribed by the basis; while an integral preserving operator is stored simply as a matrix, a non integral preserving operator is stored as a triple (L e w); the operator L corresponds to the matrix, while e w are used to guarantee that the operator Q = L + e*w preserves the integral.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"This is fundamental in our theory, since the rigorous estimate depends on the fact that the  discretized operator preserves the space of average 0 functions.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"julia> Q = DiscretizedOperator(B, D);","category":"page"},{"location":"userguide/#Bounding-the-norms-of-the-discretized-operator","page":"User guide","title":"Bounding the norms of the discretized operator","text":"","category":"section"},{"location":"userguide/","page":"User guide","title":"User guide","text":"To compute our rigorous error bound we need to compute rigorously upper bounds for the norms of the discretized operator restricted  Q^k_U_0 to the space of average 0 functions.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"This is done through the use of powernormbounds","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"julia> norms = powernormbounds(B, D; Q=Q);","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"This function infers the strong and weak norm from the basis and uses a priori  and a posteriori information to estimate these norms.","category":"page"},{"location":"userguide/#Computing-the-invariant-vector-and-the-rigorous-error","page":"User guide","title":"Computing the invariant vector and the rigorous error","text":"","category":"section"},{"location":"userguide/","page":"User guide","title":"User guide","text":"To compute the approximation and the error we use the functions  invariant_vector and distance_from_invariant.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Distance from invariant returns us an upper bound between  w and the density of the invariant a.c.i.m. with respect to the  weak norm of the basis.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"julia> w = invariant_vector(B, Q);\n\njulia> error = distance_from_invariant(B, D, Q, w, norms);\n\njulia> error <= 0.0006\ntrue\n\njulia> weak_norm(B)\nLinf","category":"page"},{"location":"userguide/#Using-the-coarse-fine-estimates","page":"User guide","title":"Using the coarse-fine estimates","text":"","category":"section"},{"location":"userguide/","page":"User guide","title":"User guide","text":"We can use now the coarse fine bounds to bound the norm of the powers of a finer discretization.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The function finepowernormbounds uses the computed norms  from the coarse discretization, the coefficients of the Doeblin-Fortet-Lasota-Yorke inequality and a computed error bound on the norm of Q_f. ","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"We first define a finer basis and compute the operator","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"julia> B_fine = Hat(16384);\n\njulia> Q_fine = DiscretizedOperator(B_fine, D);","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Then, we call the coarse fine routines","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"julia> normQ_fine = opnormbound(B_fine, weak_norm(B_fine), Q_fine)\n1.0433672005775962\n\njulia> norms_fine = finepowernormbounds(B, B_fine, D, norms; normQ_fine=normQ_fine);\n\njulia> w_fine = invariant_vector(B_fine, Q_fine);\n     \njulia> error_fine = distance_from_invariant(B_fine, D, Q_fine, w_fine, norms_fine);\n\njulia> error_fine <= 8e-5\ntrue","category":"page"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"#RigorousInvariantMeasures.jl","page":"Home","title":"RigorousInvariantMeasures.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package which implements a implements a flexible scheme to approximate rigorously invariant measures of dynamical systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find useful this package, please cite the paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"<a id=\"2\">[2]</a> Galatolo S., Nisoli I., An elementary approach to rigorous approximation of invariant measures SIAM J. Appl Dyn Sys.13 pp. 958-985 (2014)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A preprint with a full explanation of the coarse fine scheme is in preparation, by the authors Galatolo S., Monge M., Nisoli I., Poloni F.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RigorousInvariantMeasures is licensed under the MIT license; see LICENSE for the full license text.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RigorousInvariantMeasures.jl is a registered package, and is simply installed by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add(\"RigorousInvariantMeasures\")","category":"page"}]
}
