var documenterSearchIndex = {"docs":
[{"location":"api/#Library","page":"API","title":"Library","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = RigorousInvariantMeasures","category":"page"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"basis.md\", \"api.md\"]\nModules = [RigorousInvariantMeasures]\nOrder = [:type, :function]","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"We present some of the basis already implemented in the package","category":"page"},{"location":"basis/#The-Ulam-basis","page":"Basis","title":"The Ulam basis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Modules = [Base, RigorousInvariantMeasures]\nPages = [\"Ulam.jl\"]","category":"page"},{"location":"basis/#The-hat-basis-on-S1","page":"Basis","title":"The hat basis on S^1","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Modules = [Base, RigorousInvariantMeasures]\nPages = [\"HatBasis.jl\"]","category":"page"},{"location":"basis/#RigorousInvariantMeasures.Hat","page":"Basis","title":"RigorousInvariantMeasures.Hat","text":"This type represents a Hat basis on S^1. It contains a vector with the midpoints of the hats.\n\n\n\n\n\n","category":"type"},{"location":"basis/#RigorousInvariantMeasures.Hat-Tuple{Integer}","page":"Basis","title":"RigorousInvariantMeasures.Hat","text":"This constructs a Hat basis on S^1 on equispaced points\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.HatFunction","page":"Basis","title":"RigorousInvariantMeasures.HatFunction","text":"Hat function (on the reals)\n\nThis is a piecewise linear function such that: \tf(x) = 0 if x <= lo \tf(mi) = 1 \tf(hi)\n\n\n\n\n\n","category":"type"},{"location":"basis/#RigorousInvariantMeasures.HatFunctionOnTorus","page":"Basis","title":"RigorousInvariantMeasures.HatFunctionOnTorus","text":"Hat function (on the torus)\n\nThis is a piecewise linear function such that: \tf(x) = 0 if x <= lo \tf(mi) = 1 \tf(x) = 0 if x >= ho\n\n\n\n\n\n","category":"type"},{"location":"basis/#RigorousInvariantMeasures.IntervalOnTorus","page":"Basis","title":"RigorousInvariantMeasures.IntervalOnTorus","text":"A separate type for intervals on the torus (mod 1) to \"remind\" us of the quotient\n\nThe interval is normalized in the constructor: the caller may assume that\n\n0 <= i.lo < 1\ni.hi < i.lo + 1 OR i==Interval(0,1)\n\n\n\n\n\n","category":"type"},{"location":"basis/#Base.getindex-Tuple{Hat, Int64}","page":"Basis","title":"Base.getindex","text":"Base.getindex(B::Hat, i::Int)\n\nMake so that B[j] returns a HatFunctionOnTorus with the j-th basis element\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.getindex-Tuple{HatNP, Int64}","page":"Basis","title":"Base.getindex","text":"makes so that B[j] returns a  HatFunction with the j-th basis element\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.iterate-Union{Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{T, DT}}, Tuple{DT}, Tuple{T}, Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{T, DT}, Any}} where {T<:Hat, DT}","page":"Basis","title":"Base.iterate","text":"Given a preimage y of a point x, this iterator returns \\phi_j(y)/T'(y)\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.iterate-Union{Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{T, DT}}, Tuple{DT}, Tuple{T}, Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{T, DT}, Any}} where {T<:HatNP, DT}","page":"Basis","title":"Base.iterate","text":"Given a preimage y of a point x, this iterator returns \\phi_j(y)/T'(y)\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.length-Union{Tuple{HatNP{T}}, Tuple{T}} where T","page":"Basis","title":"Base.length","text":"Return the size of the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.length-Union{Tuple{Hat{T}}, Tuple{T}} where T","page":"Basis","title":"Base.length","text":"Return the size of the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, Hat, AbstractVector}","page":"Basis","title":"RecipesBase.apply_recipe","text":"Plots a function in the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, Hat, Number, Any}","page":"Basis","title":"RecipesBase.apply_recipe","text":"Displays error on a function in the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, HatNP, AbstractVector}","page":"Basis","title":"RecipesBase.apply_recipe","text":"Plots a function in the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, HatNP, Number, Any}","page":"Basis","title":"RecipesBase.apply_recipe","text":"Displays error on a function in the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.nonzero_on-Tuple{Hat, Any}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.nonzero_on","text":"BasisDefinition.nonzero_on(B::Hat, dual_element)\n\nReturn the range of indices of the elements of the basis whose support intersects with the given dual element (i.e., a pair (y, absT')). The range may end with length(B)+1; this must be interpreted \"mod length(B)\": it means that it intersects with the hat function peaked in 0 as well (think for instance y = 0.9999).\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.BasisDefinition.nonzero_on-Tuple{HatNP, Any}","page":"Basis","title":"RigorousInvariantMeasures.BasisDefinition.nonzero_on","text":"Return the range of indices of the elements of the basis whose support intersects with the given dual element (i.e., a pair (y, absT')). The range may end with length(B)+1; this must be interpreted \"mod length(B)\": it means that it intersects with the hat function peaked in 0 as well (think for instance y = 0.9999).\n\n\n\n\n\n","category":"method"},{"location":"basis/#The-hat-basis-on-[0,1]","page":"Basis","title":"The hat basis on 01","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Modules = [Base, RigorousInvariantMeasures]\nPages = [\"NonPeriodicHatBasis.jl\"]","category":"page"},{"location":"basis/#The-Chebyshev-basis","page":"Basis","title":"The Chebyshev basis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Modules = [Base, RigorousInvariantMeasures]\nPages = [\"Chebyshev.jl\"]","category":"page"},{"location":"basis/#Base.getindex-Tuple{Chebyshev, Int64}","page":"Basis","title":"Base.getindex","text":"makes so that B[j] returns a HatFunctionOnTorus with the j-th basis element\n\n\n\n\n\n","category":"method"},{"location":"basis/#Base.length-Tuple{Chebyshev}","page":"Basis","title":"Base.length","text":"Return the size of the Chebyshev basis\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures._eval_T-Union{Tuple{T}, Tuple{Any, Array{T}}} where T","page":"Basis","title":"RigorousInvariantMeasures._eval_T","text":"Eval the Chebyshev polynomial up to degree n on an array of  points in [-1, 1].\n\nNot satisfactory, the intervals explode\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.eval_Clenshaw_BackwardFirst-Union{Tuple{T}, Tuple{S}, Tuple{Array{Interval{S}, 1}, Interval{T}}} where {S, T}","page":"Basis","title":"RigorousInvariantMeasures.eval_Clenshaw_BackwardFirst","text":"Eval a polynomial in Chebyshev basis, ClenshawBackward, using ball arithmetic Following Viviane Ledoux, Guillaume Moroz  \"Evaluation of Chebyshev polynomials on intervals andapplication to root finding\"\n\n\n\n\n\n","category":"method"},{"location":"basis/#RigorousInvariantMeasures.get_norm-Tuple{RigorousInvariantMeasures.NormCacherC1}","page":"Basis","title":"RigorousInvariantMeasures.get_norm","text":"Return the norm of the matrix the NormCacher is working on.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Some examples can be found at RigorousInvariantMeasures.jl/examples/","category":"page"},{"location":"userguide/#Userguide","page":"User guide","title":"Userguide","text":"","category":"section"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The main objects involved in the approximation are the following:","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"A dynamic object\nA basis object ","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"julia> using RigorousInvariantMeasures\n\njulia> D0 = mod1_dynamic(x->4*x+0.5*x*(1-x), full_branch = true)\nPiecewise-defined dynamic with 4 branches\n\njulia> D = D0∘D0∘D0\nRigorousInvariantMeasures.ComposedDynamic((RigorousInvariantMeasures.ComposedDynamic((Piecewise-defined dynamic with 4 branches, Piecewise-defined dynamic with 4 branches), Piecewise-defined dynamic with 16 branches), Piecewise-defined dynamic with 4 branches), Piecewise-defined dynamic with 64 branches)\n\njulia> B = Hat(1024)\nHat{LinRange{Float64, Int64}}(range(0.0, stop=1.0, length=1025))","category":"page"},{"location":"userguide/#Building-the-discretized-operator","page":"User guide","title":"Building the discretized operator","text":"","category":"section"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Once a basis is chosen we call DiscretizedOperator to compute the discretized operator.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Remark that a discretized operator can be of two types:","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"IntegralPreservingDiscretizedOperator\nNonIntegralPreservingDiscretizedOperator","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The type of the discretized operator is prescribed by the basis; while an integral preserving operator is stored simply as a matrix, a non integral preserving operator is stored as a triple (L e w); the operator L corresponds to the matrix, while e w are used to guarantee that the operator Q = L + e*w preserves the integral.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"This is fundamental in our theory, since the rigorous estimate depends on the fact that the  discretized operator preserves the space of average 0 functions.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"julia> Q = DiscretizedOperator(B, D);","category":"page"},{"location":"userguide/#Bounding-the-norms-of-the-discretized-operator","page":"User guide","title":"Bounding the norms of the discretized operator","text":"","category":"section"},{"location":"userguide/","page":"User guide","title":"User guide","text":"To compute our rigorous error bound we need to compute rigorously upper bounds for the norms of the discretized operator restricted  Q^k_U_0 to the space of average 0 functions.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"This is done through the use of powernormbounds","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"julia> norms = powernormbounds(B, D; Q=Q);","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"This function infers the strong and weak norm from the basis and uses a priori  and a posteriori information to estimate these norms.","category":"page"},{"location":"userguide/#Computing-the-invariant-vector-and-the-rigorous-error","page":"User guide","title":"Computing the invariant vector and the rigorous error","text":"","category":"section"},{"location":"userguide/","page":"User guide","title":"User guide","text":"To compute the approximation and the error we use the functions  invariant_vector and distance_from_invariant.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Distance from invariant returns us an upper bound between  w and the density of the invariant a.c.i.m. with respect to the  weak norm of the basis.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"julia> w = invariant_vector(B, Q);\n\njulia> error = distance_from_invariant(B, D, Q, w, norms);\n\njulia> error <= 0.0006\ntrue\n\njulia> weak_norm(B)\nLinf","category":"page"},{"location":"userguide/#Using-the-coarse-fine-estimates","page":"User guide","title":"Using the coarse-fine estimates","text":"","category":"section"},{"location":"userguide/","page":"User guide","title":"User guide","text":"We can use now the coarse fine bounds to bound the norm of the powers of a finer discretization.","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"The function finepowernormbounds uses the computed norms  from the coarse discretization, the coefficients of the Doeblin-Fortet-Lasota-Yorke inequality and a computed error bound on the norm of Q_f. ","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"We first define a finer basis and compute the operator","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"julia> B_fine = Hat(16384);\n\njulia> Q_fine = DiscretizedOperator(B_fine, D);","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"Then, we call the coarse fine routines","category":"page"},{"location":"userguide/","page":"User guide","title":"User guide","text":"julia> normQ_fine = opnormbound(B_fine, weak_norm(B_fine), Q_fine)\n1.0433672005775962\n\njulia> norms_fine = finepowernormbounds(B, B_fine, D, norms; normQ_fine=normQ_fine);\n\njulia> w_fine = invariant_vector(B_fine, Q_fine);\n     \njulia> error_fine = distance_from_invariant(B_fine, D, Q_fine, w_fine, norms_fine);\n\njulia> error_fine <= 8e-5\ntrue","category":"page"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"#RigorousInvariantMeasures.jl","page":"Home","title":"RigorousInvariantMeasures.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package which implements a implements a flexible scheme to approximate rigorously invariant measures of dynamical systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find useful this package, please cite the paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"<a id=\"2\">[2]</a> Galatolo S., Nisoli I., An elementary approach to rigorous approximation of invariant measures SIAM J. Appl Dyn Sys.13 pp. 958-985 (2014)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A preprint with a full explanation of the coarse fine scheme is in preparation, by the authors Galatolo S., Monge M., Nisoli I., Poloni F.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RigorousInvariantMeasures is licensed under the MIT license; see LICENSE for the full license text.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RigorousInvariantMeasures.jl is a registered package, and is simply installed by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add(\"RigorousInvariantMeasures\")","category":"page"}]
}
