var documenterSearchIndex = {"docs":
[{"location":"api/#Library","page":"API","title":"Library","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = RigorousInvariantMeasures","category":"page"},{"location":"api/#Module","page":"API","title":"Module","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [RigorousInvariantMeasures]\nOrder = [:type, :function]","category":"page"},{"location":"api/#RigorousInvariantMeasures.CoarseGridQuantities","page":"API","title":"RigorousInvariantMeasures.CoarseGridQuantities","text":"Struct that encapsulates the additional quantities needed on the coarse basis for a two-grid estimate, or on the (only) basis for a one-grid estimate.  It is meant as an intermediate quantity that can be saved on the disk to avoid recomputing Q all the times.\n\n\n\n\n\n","category":"type"},{"location":"api/#RigorousInvariantMeasures.ComposedDynamic","page":"API","title":"RigorousInvariantMeasures.ComposedDynamic","text":"Composed map D1 ∘ D2 ∘ D3. We store with [D1, D2, D3] in this order.\n\nWe overwrite ∘ in base, so one can simply write D1 ∘ D2 or ∘(D1, D2, D3) to construct them.\n\n\n\n\n\n","category":"type"},{"location":"api/#RigorousInvariantMeasures.Dual","page":"API","title":"RigorousInvariantMeasures.Dual","text":"Replacement of DualComposedWithDynamic.\n\n\n\n\n\n","category":"type"},{"location":"api/#RigorousInvariantMeasures.FineGridQuantities","page":"API","title":"RigorousInvariantMeasures.FineGridQuantities","text":"Struct that encapsulates all the quantities computed from the fine basis that are needed in the two-grid estimate. It is meant as an intermediate quantity that can be saved on the disk to avoid recomputing Q all the times\n\n\n\n\n\n","category":"type"},{"location":"api/#RigorousInvariantMeasures.Fourier1D-Tuple{Integer}","page":"API","title":"RigorousInvariantMeasures.Fourier1D","text":"Fourier(N) builds a Fourier basis truncating at frequence N by default it uses a FFT of size 2^(log2(ceil(N))+2)\n\nFourier(N, FFTNx) builds a Fourier basis with FFT size FFTNx\n\nThe base size is 2*N+1 (0, ..., N, -N, ..., -1)\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.Hat","page":"API","title":"RigorousInvariantMeasures.Hat","text":"This type represents a Hat basis on S^1. It contains a vector with the midpoints of the hats.\n\n\n\n\n\n","category":"type"},{"location":"api/#RigorousInvariantMeasures.Hat-Tuple{Integer}","page":"API","title":"RigorousInvariantMeasures.Hat","text":"This constructs a Hat basis on S^1 on equispaced points\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.HatFunction","page":"API","title":"RigorousInvariantMeasures.HatFunction","text":"Hat function (on the reals)\n\nThis is a piecewise linear function such that: \tf(x) = 0 if x <= lo \tf(mi) = 1 \tf(hi)\n\n\n\n\n\n","category":"type"},{"location":"api/#RigorousInvariantMeasures.HatFunctionOnTorus","page":"API","title":"RigorousInvariantMeasures.HatFunctionOnTorus","text":"Hat function (on the torus)\n\nThis is a piecewise linear function such that: \tf(x) = 0 if x <= lo \tf(mi) = 1 \tf(x) = 0 if x >= ho\n\n\n\n\n\n","category":"type"},{"location":"api/#RigorousInvariantMeasures.IntervalOnTorus","page":"API","title":"RigorousInvariantMeasures.IntervalOnTorus","text":"A separate type for intervals on the torus (mod 1) to \"remind\" us of the quotient\n\nThe interval is normalized in the constructor: the caller may assume that\n\n0 <= i.lo < 1\ni.hi < i.lo + 1 OR i==Interval(0,1)\n\n\n\n\n\n","category":"type"},{"location":"api/#RigorousInvariantMeasures.NonIntegralPreservingDiscretizedOperator","page":"API","title":"RigorousInvariantMeasures.NonIntegralPreservingDiscretizedOperator","text":"An operator of the form Q = L + e*w (sparse plus rank-1).\n\n\n\n\n\n","category":"type"},{"location":"api/#RigorousInvariantMeasures.NormCacher","page":"API","title":"RigorousInvariantMeasures.NormCacher","text":"Types to compute norms iteratively by \"adding a column at a time\".\n\n\n\n\n\n","category":"type"},{"location":"api/#RigorousInvariantMeasures.NormCacher-Union{Tuple{L1}, Tuple{Any, Any}} where L1","page":"API","title":"RigorousInvariantMeasures.NormCacher","text":"Create a new NormCacher to compute the normbound of the empty matrix with n rows\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.Ulam","page":"API","title":"RigorousInvariantMeasures.Ulam","text":"Equispaced Ulam basis on [0,1] of size n\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.getindex-Tuple{Chebyshev, Int64}","page":"API","title":"Base.getindex","text":"makes so that B[j] returns a HatFunctionOnTorus with the j-th basis element\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Hat, Int64}","page":"API","title":"Base.getindex","text":"makes so that B[j] returns a HatFunctionOnTorus with the j-th basis element\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{HatNP, Int64}","page":"API","title":"Base.getindex","text":"makes so that B[j] returns a  HatFunction with the j-th basis element\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.iterate-Union{Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{BT, DT}}, Tuple{DT}, Tuple{BT}, Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{BT, DT}, Any}} where {BT<:Ulam, DT}","page":"API","title":"Base.iterate","text":"Given a preimage of an interval I_i, this iterator returns its relative intersection with all the elements of the Ulam basis that have nonzero intersection with it\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.iterate-Union{Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{T, DT}}, Tuple{DT}, Tuple{T}, Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{T, DT}, Any}} where {T<:Hat, DT}","page":"API","title":"Base.iterate","text":"Given a preimage y of a point x, this iterator returns \\phi_j(y)/T'(y)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.iterate-Union{Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{T, DT}}, Tuple{DT}, Tuple{T}, Tuple{RigorousInvariantMeasures.BasisDefinition.ProjectDualElement{T, DT}, Any}} where {T<:HatNP, DT}","page":"API","title":"Base.iterate","text":"Given a preimage y of a point x, this iterator returns \\phi_j(y)/T'(y)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{Chebyshev}","page":"API","title":"Base.length","text":"Return the size of the Chebyshev basis\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Union{Tuple{HatNP{T}}, Tuple{T}} where T","page":"API","title":"Base.length","text":"Return the size of the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Union{Tuple{Hat{T}}, Tuple{T}} where T","page":"API","title":"Base.length","text":"Return the size of the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesBase.apply_recipe","page":"API","title":"RecipesBase.apply_recipe","text":"Displays error on a function in the Ulam basis\n\nThe w argument is unused, but kept for compatibility with other functions for different bases\n\n\n\n\n\n","category":"function"},{"location":"api/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, Hat, AbstractVector}","page":"API","title":"RecipesBase.apply_recipe","text":"Plots a function in the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, Hat, Number, Any}","page":"API","title":"RecipesBase.apply_recipe","text":"Displays error on a function in the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, HatNP, AbstractVector}","page":"API","title":"RecipesBase.apply_recipe","text":"Plots a function in the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, HatNP, Number, Any}","page":"API","title":"RecipesBase.apply_recipe","text":"Displays error on a function in the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, Ulam, AbstractVector}","page":"API","title":"RecipesBase.apply_recipe","text":"Plots a function in the Ulam basis\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.BasisDefinition.nonzero_on-Tuple{Hat, Any}","page":"API","title":"RigorousInvariantMeasures.BasisDefinition.nonzero_on","text":"Return the range of indices of the elements of the basis whose support intersects with the given dual element (i.e., a pair (y, absT')). The range may end with length(B)+1; this must be interpreted \"mod length(B)\": it means that it intersects with the hat function peaked in 0 as well (think for instance y = 0.9999).\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.BasisDefinition.nonzero_on-Tuple{HatNP, Any}","page":"API","title":"RigorousInvariantMeasures.BasisDefinition.nonzero_on","text":"Return the range of indices of the elements of the basis whose support intersects with the given dual element (i.e., a pair (y, absT')). The range may end with length(B)+1; this must be interpreted \"mod length(B)\": it means that it intersects with the hat function peaked in 0 as well (think for instance y = 0.9999).\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.BasisDefinition.nonzero_on-Tuple{Ulam, Any}","page":"API","title":"RigorousInvariantMeasures.BasisDefinition.nonzero_on","text":"Returns the indices of the elements of the Ulam basis that intersect with the interval y We do not assume an order of a and b; this should not matter unless the preimages are computed with very low accuracy We assume, though, that y comes from the (possibly inexact) numerical approximation of an interval in [0,1], i.e., we restrict to y ∩ [0,1]\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.BasisDefinition.normbound-Tuple{Type{L1}, AbstractVector}","page":"API","title":"RigorousInvariantMeasures.BasisDefinition.normbound","text":"Rigorous upper bound on a vector norm. Note that Linf, L1 are the \"analyst's\" norms\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.BasisDefinition.opnormbound-Tuple{Fourier1D, Type{L2}, Any}","page":"API","title":"RigorousInvariantMeasures.BasisDefinition.opnormbound","text":"This function bounds the L2 operator norm of M (complex floating point matrix)\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.BasisDefinition.opnormbound-Union{Tuple{T}, Tuple{Type{L1}, AbstractVecOrMat{T}}} where T","page":"API","title":"RigorousInvariantMeasures.BasisDefinition.opnormbound","text":"Certified upper bound to ||A|| (of specified NormKind)\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.BasisDefinition.opnormbound-Union{Tuple{T}, Tuple{Type{L2}, Vector{T}}} where T<:Real","page":"API","title":"RigorousInvariantMeasures.BasisDefinition.opnormbound","text":"These functions compute a rigorous upper bound for the 2-norm of a vector; we have a specialized version for complex numbers to avoid taking the sqrt root and squaring again \n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.DynamicDefinition.domain-Tuple{RigorousInvariantMeasures.ComposedDynamic}","page":"API","title":"RigorousInvariantMeasures.DynamicDefinition.domain","text":"Utility function to return the domain of a dynamic\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures._eval_T-Union{Tuple{T}, Tuple{Any, Array{T}}} where T","page":"API","title":"RigorousInvariantMeasures._eval_T","text":"Eval the Chebyshev polynomial up to degree n on an array of  points in [-1, 1].\n\nNot satisfactory, the intervals explode\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.abs_or_mag-Tuple{Number}","page":"API","title":"RigorousInvariantMeasures.abs_or_mag","text":"'Absolute value' definition that returns mag(I) for an interval and abs(x) for a real\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.add_column!-Tuple{RigorousInvariantMeasures.NormCacherL1, AbstractVector, Float64}","page":"API","title":"RigorousInvariantMeasures.add_column!","text":"Update a NormCacher to add one column to the matrix it is computing a norm of. This column may be affected by an error ε (in the same norm).\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.assemble","page":"API","title":"RigorousInvariantMeasures.assemble","text":"Assembles the truncated Fourier matrix for a dynamic D,  with frequencies -Nx≤ i≤ Nx\n\nInput:     B:: Fourier1D basis     D: Dynamic     T: Floating point type, supports Float64, BigFloat\n\nOutput:\nM: matrix of intervals that rigorously contain M\n\n\n\n\n\n","category":"function"},{"location":"api/#RigorousInvariantMeasures.boundnorm-Union{Tuple{T}, Tuple{Basis, AbstractArray{Interval{T}, 2}, Any}} where T","page":"API","title":"RigorousInvariantMeasures.boundnorm","text":"This function returns the bound on the weak norm of the discretized operator\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.compute_coarse_grid_quantities-Tuple{Any, Any}","page":"API","title":"RigorousInvariantMeasures.compute_coarse_grid_quantities","text":"Compute FineGridQuantities and CoarseGridQuantities, given a function f(n) that computes B, D, Q = f(n)\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.compute_fine_grid_quantities-Tuple{Any, Any}","page":"API","title":"RigorousInvariantMeasures.compute_fine_grid_quantities","text":"Compute FineGridQuantities, given a function f(n) that computes B, D, Q = f(n)\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.dfly-Tuple{Type{<:NormKind}, Type{<:NormKind}, Dynamic}","page":"API","title":"RigorousInvariantMeasures.dfly","text":"(A, B) = dfly(strongnorm, auxnorm, dynamic)\n\nConstants (A, B) such that ||Lf||s ≦ A||f||s + B||f||_aux\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.distance_from_invariant-Tuple{Basis, Dynamic, Union{Nothing, DiscretizedOperator}, AbstractVector, Vector}","page":"API","title":"RigorousInvariantMeasures.distance_from_invariant","text":"Bounds rigorously the distance of w from the fixed point of Q (normalized with integral = 1), using a vector of bounds norms[k] ≥ ||Qh^k|{U_h^0}||. If ε₁ and normQ are given, then Q can be omitted\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.distance_from_invariant_noise-Tuple{Basis, DiscretizedOperator, RigorousInvariantMeasures.NoiseKernel, AbstractVector, Vector}","page":"API","title":"RigorousInvariantMeasures.distance_from_invariant_noise","text":"Bounds rigorously the distance of w from the fixed point of Q (normalized with integral = 1), using a vector of bounds norms[k] ≥ ||Qh^k|{U_h^0}||.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.eval_Clenshaw_BackwardFirst-Union{Tuple{T}, Tuple{S}, Tuple{Array{Interval{S}, 1}, Interval{T}}} where {S, T}","page":"API","title":"RigorousInvariantMeasures.eval_Clenshaw_BackwardFirst","text":"Eval a polynomial in Chebyshev basis, ClenshawBackward, using ball arithmetic Following Viviane Ledoux, Guillaume Moroz  \"Evaluation of Chebyshev polynomials on intervals andapplication to root finding\"\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.faster_certify-Tuple{Any, Any, Any}","page":"API","title":"RigorousInvariantMeasures.faster_certify","text":"This function uses the classical bound, cited in\n\nRESIDUAL BOUNDS ON APPROXIMATE EIGENSYSTEMS OF NONNORMAL MATRICES* W. KAHAN, B. N. PARLETT AND E. JIANGt\n\nTheorem 1\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.finepowernormbounds-NTuple{4, Any}","page":"API","title":"RigorousInvariantMeasures.finepowernormbounds","text":"Uses power norm bounds already computed for a coarse operator to estimate the same norms for a finer operator\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.finepowernormboundsnoise-Tuple{Any, Any, Any}","page":"API","title":"RigorousInvariantMeasures.finepowernormboundsnoise","text":"Uses power norm bounds already computed for a coarse operator to estimate the same norms for a finer operator\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.first_overlapping-Tuple{Any, Any}","page":"API","title":"RigorousInvariantMeasures.first_overlapping","text":"Smallest possible i such that a is in the semi-open interval [y[i], y[i+1]).\n\nThis should work properly even if a, y are intervals; in this case it returns the smallest possible value of i over all possible \"assignments\" of a, y inside those intervals. Assumes y is sorted, i.e., map(y, x->Interval(x).lo) and map(y, x->Interval(x).hi) are sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.gamma-Tuple{Any, Integer}","page":"API","title":"RigorousInvariantMeasures.gamma","text":"γₙ constants for floating point error estimation, as in [Higham, Accuracy and Stability of Numerical Algorithms]\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.get_norm-Tuple{RigorousInvariantMeasures.NormCacherC1}","page":"API","title":"RigorousInvariantMeasures.get_norm","text":"Return the norm of the matrix the NormCacher is working on.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.get_norm-Tuple{RigorousInvariantMeasures.NormCacherL1}","page":"API","title":"RigorousInvariantMeasures.get_norm","text":"Return the norm of the matrix the NormCacher is working on.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.infinite_sum_norms-Tuple{Vector}","page":"API","title":"RigorousInvariantMeasures.infinite_sum_norms","text":"Estimate ||I + Q + Q^2 + … || (infinite sum) using a list of computed norm bounds norms[k] ≥ ||Q^k||.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.invariant_vector-Tuple{Basis, DiscretizedOperator}","page":"API","title":"RigorousInvariantMeasures.invariant_vector","text":"Return a numerical approximation to the (hopefully unique) invariant vector of the dynamic with discretized operator Q.\n\nThe vector is normalized so that integral_covector(B)*w ≈ 1\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.invariant_vector_noise-Tuple{Basis, DiscretizedOperator, RigorousInvariantMeasures.NoiseKernel}","page":"API","title":"RigorousInvariantMeasures.invariant_vector_noise","text":"Return a numerical approximation to the (hopefully unique) invariant vector of the dynamic with discretized operator Q.\n\nThe vector is normalized so that integral_covector(B)*w ≈ 1\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.last_overlapping-Tuple{Any, Any}","page":"API","title":"RigorousInvariantMeasures.last_overlapping","text":"Largest possible j such that a-ε is in the semi-open interval [y[j], y[j+1]).\n\nThis should work properly even if a, y are intervals; in this case it returns the largest possible value of i over all possible \"assignments\" of a, y inside those intervals. Assumes y is sorted, i.e., map(y, x->Interval(x).lo) and map(y, x->Interval(x).hi) are sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.max_nonzeros_per_row-Tuple{SparseArrays.SparseMatrixCSC}","page":"API","title":"RigorousInvariantMeasures.max_nonzeros_per_row","text":"Returns the maximum number of (structural) nonzeros in a row of A\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.norm_2_estimator_square_nonrig-Tuple{Any}","page":"API","title":"RigorousInvariantMeasures.norm_2_estimator_square_nonrig","text":"This function computes a candidate for the top singular value of M|{V0} square, i.e., it returns λ^2 and the associated singular vector \n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.norms_of_powers-Tuple{Basis, Type{<:NormKind}, Integer, DiscretizedOperator, AbstractArray}","page":"API","title":"RigorousInvariantMeasures.norms_of_powers","text":"Estimates the norms ||Q||, ||Q^2||, ... ||Q^m|| on U^0.\n\nU is the matrix [ones(1,n-1); -I_(n-1,n-1)]. It is currently assumed that f*U==0 (i.e., all elements of f are equal).\n\nf must be an interval vector.\n\nThe following constants may be specified as keyword arguments:\n\nnormQ, normE, normv0, normEF, normIEF, normN\n\notherwise they are computed (which may be slower).\n\ne and f must be specified in case isintegralpreserving==false In case isintegralpreserving is true, they may be specified but they are then ignored.\n\nImplementation note: currently we perform this computation one column at a time, to be able to scale (slowly) to cases with large size; for moderate sizes, it would indeed be better to do the computation all columns at the same time, in BLAS level 3.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.norms_of_powers_abstract_noise-Tuple{Basis, RigorousInvariantMeasures.NoiseKernel, Any}","page":"API","title":"RigorousInvariantMeasures.norms_of_powers_abstract_noise","text":"Arrays of bounds to ||Q^k||{w → s} = sup{||f||w=1} ||Q^k f||s and to ||Q^k||_{w} coming theoretically from iterated DFLY inequalities (the \"small matrix method\").\n\nReturns two arrays (strongs, norms) of length m: strongs[k] bounds ||Q^k f||_s, norms[k] bounds ||Q^k f||)\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.norms_of_powers_dfly-Tuple{Basis, Dynamic, Any}","page":"API","title":"RigorousInvariantMeasures.norms_of_powers_dfly","text":"Arrays of bounds to ||Q^k||{w → s} = sup{||f||w=1} ||Q^k f||s and to ||Q^k||_{w} coming theoretically from iterated DFLY inequalities (the \"small matrix method\").\n\nReturns two arrays (strongs, norms) of length m: strongs[k] bounds ||Q^k f||_s, norms[k] bounds ||Q^k f||)\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.norms_of_powers_from_coarser_grid-Tuple{Basis, Basis, Dynamic, Vector, Real}","page":"API","title":"RigorousInvariantMeasures.norms_of_powers_from_coarser_grid","text":"Estimate norms of powers from those on a coarser grid (see paper for details)\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.norms_of_powers_from_coarser_grid_noise-Tuple{Fourier1D, Fourier1D, DiscretizedOperator, RigorousInvariantMeasures.NoiseKernel, Vector}","page":"API","title":"RigorousInvariantMeasures.norms_of_powers_from_coarser_grid_noise","text":"Estimate norms of powers from those on a coarser grid (see paper for details) TODO: Check the final formula!!!\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.norms_of_powers_from_coarser_grid_noise-Tuple{Ulam, Ulam, DiscretizedOperator, RigorousInvariantMeasures.NoiseKernel, Vector}","page":"API","title":"RigorousInvariantMeasures.norms_of_powers_from_coarser_grid_noise","text":"Estimate norms of powers from those on a coarser grid (see paper for details) TODO: Check if it works for other basis types\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.norms_of_powers_noise-Tuple{Ulam, Type{L1}, Integer, DiscretizedOperator, RigorousInvariantMeasures.NoiseKernel, AbstractArray}","page":"API","title":"RigorousInvariantMeasures.norms_of_powers_noise","text":"Estimates the norms ||Q||, ||Q^2||, ... ||Q^m|| on U^0.\n\nU is the matrix [ones(1,n-1); -I_(n-1,n-1)]. It is currently assumed that f*U==0 (i.e., all elements of f are equal).\n\nf must be an interval vector.\n\nThe following constants may be specified as keyword arguments:\n\nnormQ, normE, normv0, normEF, normIEF, normN\n\notherwise they are computed (which may be slower).\n\ne and f must be specified in case isintegralpreserving==false In case isintegralpreserving is true, they may be specified but they are then ignored.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.norms_of_powers_trivial-Tuple{Real, Integer}","page":"API","title":"RigorousInvariantMeasures.norms_of_powers_trivial","text":"Array of \"trivial\" bounds for the powers of a DiscretizedOperator (on the whole space) coming from from ||Q^k|| ≤ ||Q||^k\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.norms_of_powers_trivial_noise-Tuple{Fourier1D, Type{L2}, DiscretizedOperator, RigorousInvariantMeasures.NoiseKernel, Integer}","page":"API","title":"RigorousInvariantMeasures.norms_of_powers_trivial_noise","text":"Array of \"trivial\" bounds for the powers of a DiscretizedOperator (on the whole space) coming from from ||Q^k|| ≤ ||Q||^k\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.norms_of_powers_trivial_noise-Tuple{Type{<:NormKind}, DiscretizedOperator, RigorousInvariantMeasures.NoiseKernel, Integer}","page":"API","title":"RigorousInvariantMeasures.norms_of_powers_trivial_noise","text":"Array of \"trivial\" bounds for the powers of a DiscretizedOperator (on the whole space) coming from from ||Q^k|| ≤ ||Q||^k\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.one_grid_estimate-Tuple{RigorousInvariantMeasures.CoarseGridQuantities, RigorousInvariantMeasures.FineGridQuantities}","page":"API","title":"RigorousInvariantMeasures.one_grid_estimate","text":"Compute a one-grid error estimate.\n\nThe first return argument is the error, the second is the time breakdown according to [\"dfly\", \"assembling\", \"eigen\", \"norms\", \"error\"].  (The sum of that vector is the total time taken)\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.powernormbounds-NTuple{4, Any}","page":"API","title":"RigorousInvariantMeasures.powernormbounds","text":"Uses different strategies to compute power norm bounds.\n\nIf specified, m norms of powers are estimated computationally, and then m_extend norms are obtained with a cheaper refinement process. Otherwise these numbers are selected automatically.\n\nA vector of length mextend is returned, such that norms[k] ≥ ||Qh^k|{Uh^0}||\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.powernormbounds-Tuple{Any, Any}","page":"API","title":"RigorousInvariantMeasures.powernormbounds","text":"Computes bounds for norms of powers, taking (optionally) minimum values for the number of norms to compute\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.preimages","page":"API","title":"RigorousInvariantMeasures.preimages","text":"Construct preimages of an increasing array y under a monotonic branch defined on X = (a, b), propagating additional labels ylabel\n\nThe sequence y subdivides the y-axis into semi-open intervals [y[l], y[l+1]); each of them is identified by the label ylabel[l]. We construct an increasing sequence  x that splits X (in the x-axis) into semi-open intervals, each of them with f([x[k], x[k+1]) ⊂ [y[l], y[l+1]) for a certain l.  We set xlabel[k] = ylabel[l], and return the pair (x, xlabel).\n\nIt is assumed that it cannot happen that f(x) < y[1].\n\nIn the simplest case where D is full-branch, the points in x are preimages of the points in y, but in the general case they can also include D.endpoints: in general, there may be a certain number of points in y that have no preimage at the beginning and the end of the sequence, because  they fall out of the range R = [f(a), f(b)]. In the worst case, no point has a preimage, because y[i] < R < y[i+1] for some  i (or vice versa with orientations), and in this case we just return the 1-element vectors x = [branch.X[1]] and xlabel = [i].\n\nx[begin] always coincides with branch.X[1], while branch.X[2] is \"the point after x[end]\", and is not stored explicitly in x, for easier composing. In this way x and xlabel have the same length.\n\nThis function fills the array by using a bisection strategy to save computations: if y ∈ [a,b], then f⁻¹(y) ∈ f⁻¹(a),f⁻¹(b). So we can fill v by filling in first entries v[k+1] with higher dyadic valuation of k.\n\nFor a dynamic with multiple branches, preimages(y, D) is simply the concatenation of x, xlabel for b in all branches. These values still form an increasing sequence that splits X into intervals, each of which is mapped into a different semi-open interval [y[k], y[k+1]).\n\n\n\n\n\n","category":"function"},{"location":"api/#RigorousInvariantMeasures.preimages_and_derivatives","page":"API","title":"RigorousInvariantMeasures.preimages_and_derivatives","text":"Compute preimages of D and the derivatives f'(x) in each point.\n\nReturns: x, xlabel, x′\n\nAssumes that the dynamic is full-branch, because otherwise things may compose the wrong way. This is not restrictive because we'll need it only for the Hat assembler (at the moment)\n\nWe combine them in a single function because there are avenues to optimize by recycling some computations (not completely exploited for now)\n\n\n\n\n\n","category":"function"},{"location":"api/#RigorousInvariantMeasures.refine_norms_of_powers-Tuple{Vector, Any}","page":"API","title":"RigorousInvariantMeasures.refine_norms_of_powers","text":"Compute better and/or more estimates of power norms using the fact that ||Q^{k+h}|| ≤ ||Q^k|| * ||Q^h||. This uses multiplicativity, so it will not work for mixed norms, e.g., ||Q^k||{s → w}, or ||M^k|{U^0}|| (unless M preserves U^0, which is the case for Q|_{U^0}).\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.relative_measure-Tuple{Tuple{Interval, Interval}, Tuple{Interval, Interval}}","page":"API","title":"RigorousInvariantMeasures.relative_measure","text":"Relative measure of the intersection of (a,b) wrt the whole interval (c,d) Assumes that a,b and c,d are sorted correctly\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.residualbound-Tuple{Basis, Type{<:NormKind}, DiscretizedOperator, AbstractVector}","page":"API","title":"RigorousInvariantMeasures.residualbound","text":"Return an upper bound to Q_h*w - w in the given norm\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.residualboundnoise-Tuple{Basis, Type{<:NormKind}, DiscretizedOperator, RigorousInvariantMeasures.NoiseKernel, AbstractVector}","page":"API","title":"RigorousInvariantMeasures.residualboundnoise","text":"Return an upper bound to Q_h*w - w in the given norm\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.rigorous_norm-Tuple{Matrix{Interval}}","page":"API","title":"RigorousInvariantMeasures.rigorous_norm","text":"rigorous_norm(M; k = 10)\n\nComputes the L² and L∞ norm of the powers of M|_V₀ up to the power k. The algorithm first computes a numeric estimate of the top Singular Value and then certifies it by an Interval Newton step\n\nOutputs: v2\n\nv₂ : it is the vector with the rigorous bounds on the L² norm      these are obtained by observing that      ||f||₂ = ||w||₂,       where w is the vector of the Fourier coefficients of the trigonometric polynomial f\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.two_grid_estimate-Tuple{RigorousInvariantMeasures.CoarseGridQuantities, RigorousInvariantMeasures.FineGridQuantities}","page":"API","title":"RigorousInvariantMeasures.two_grid_estimate","text":"Compute a two-grid error estimate.\n\nThe first return argument is the error, the second is the time breakdown according to [\"dfly\", \"coarse\", \"assembling\", \"eigen\", \"norms\", \"error\"].  (The sum of that vector is the total time taken)\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.z_times_conjz-Tuple{Complex}","page":"API","title":"RigorousInvariantMeasures.z_times_conjz","text":"Computes a rigorous upper bound for z*z'\n\n\n\n\n\n","category":"method"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]\nModules = [RigorousInvariantMeasures]\nOrder = [:type, :function]","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"userguide/#Userguide","page":"User guide","title":"Userguide","text":"","category":"section"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"#RigorousInvariantMeasures.jl","page":"Home","title":"RigorousInvariantMeasures.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package which implements a implements a flexible scheme to approximate rigorously invariant measures of dynamical systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find useful this package, please cite the paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"<a id=\"2\">[2]</a> Galatolo S., Nisoli I., An elementary approach to rigorous approximation of invariant measures SIAM J. Appl Dyn Sys.13 pp. 958-985 (2014)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A preprint with a full explanation of the coarse fine scheme is in preparation, by the authors Galatolo S., Monge M., Nisoli I., Poloni F.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RigorousInvariantMeasures is licensed under the MIT license; see LICENSE for the full license text.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RigorousInvariantMeasures.jl is a registered package, and is simply installed by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add(\"RigorousInvariantMeasures\")","category":"page"}]
}
