var documenterSearchIndex = {"docs":
[{"location":"GenericAssembler/#Generic-assembler","page":"Generic assembler interface","title":"Generic assembler","text":"","category":"section"},{"location":"GenericAssembler/","page":"Generic assembler interface","title":"Generic assembler interface","text":"This is the generic assembler interface and types; the idea is that the method are dispatched based on the basis type and the dynamic type.","category":"page"},{"location":"GenericAssembler/#RigorousInvariantMeasures.DiscretizedOperator","page":"Generic assembler interface","title":"RigorousInvariantMeasures.DiscretizedOperator","text":"This is an abstract type representing a discretized operator\n\n\n\n\n\n","category":"type"},{"location":"GenericAssembler/#RigorousInvariantMeasures.DiscretizedOperator-Tuple{Any, Any}","page":"Generic assembler interface","title":"RigorousInvariantMeasures.DiscretizedOperator","text":"DiscretizedOperator(B, D; ϵ = 10^(-14), max_iter = 100, T = Float64)\n\nConstructor of a discretized operator, it infers if the operator  is integral preserving or not from the basis B\n\nArguments:     B Basis     D Dynamic      ϵ stopping condition for the Newton method     max_iter maximum number of Newton method iterate     T type of the elements stored in the matrix\n\n\n\n\n\n","category":"method"},{"location":"GenericAssembler/#RigorousInvariantMeasures.IntegralPreservingDiscretizedOperator","page":"Generic assembler interface","title":"RigorousInvariantMeasures.IntegralPreservingDiscretizedOperator","text":"This type represents an operator that preserves the value of the integral\n\n\n\n\n\n","category":"type"},{"location":"GenericAssembler/#RigorousInvariantMeasures.NonIntegralPreservingDiscretizedOperator","page":"Generic assembler interface","title":"RigorousInvariantMeasures.NonIntegralPreservingDiscretizedOperator","text":"An operator of the form Q = L + e*w (sparse plus rank-1); this \nis an operator that has been corrected to preserve the integral\n\n\n\n\n\n","category":"type"},{"location":"Dynamic/","page":"Dynamic","title":"Dynamic","text":"These are some implemented methods for building dynamics","category":"page"},{"location":"Dynamic/#Abstract-Dynamic-Definition","page":"Dynamic","title":"Abstract Dynamic Definition","text":"","category":"section"},{"location":"Dynamic/#RigorousInvariantMeasures.endpoints","page":"Dynamic","title":"RigorousInvariantMeasures.endpoints","text":"endpoints(S::Dynamic)\n\nEndpoints of the branches, in increasing order (returned as a vector of intervals)\n\n\n\n\n\n","category":"function"},{"location":"Dynamic/#RigorousInvariantMeasures.max_distortion","page":"Dynamic","title":"RigorousInvariantMeasures.max_distortion","text":"Maximum of \n\nfracT(T)^2 \n\nover all branches\n\n\n\n\n\n","category":"function"},{"location":"Dynamic/#RigorousInvariantMeasures.max_inverse_derivative","page":"Dynamic","title":"RigorousInvariantMeasures.max_inverse_derivative","text":"Maximum of \n\nfrac1T\n\nover all branches\n\n\n\n\n\n","category":"function"},{"location":"Dynamic/#RigorousInvariantMeasures.plottable","page":"Dynamic","title":"RigorousInvariantMeasures.plottable","text":"Return a non-interval version of the map as a function. This can be used, for instance, for plot(plottable(D)).\n\n\n\n\n\n","category":"function"},{"location":"Dynamic/#RigorousInvariantMeasures.preim","page":"Dynamic","title":"RigorousInvariantMeasures.preim","text":"preim(S::Dynamic, k, y, ϵ)\n\nComputes the preim of y in branch k of a dynamic, with accuracy ϵ\n\n\n\n\n\n","category":"function"},{"location":"Dynamic/#One-dimensional-piecewise-monotone-map-definition","page":"Dynamic","title":"One dimensional piecewise monotone map definition","text":"","category":"section"},{"location":"Dynamic/#RigorousInvariantMeasures.MonotonicBranch","page":"Dynamic","title":"RigorousInvariantMeasures.MonotonicBranch","text":"Type used to represent a \"branch\" of a dynamic. The branch is represented by a map f with domain X=(a,b). X[1] and X[2] are interval enclosures of a,b.\n\nThe map must be monotonic on [a,b]. Note that this is not the same thing as being monotonic on hull(X[1], X[2]):  for instance, take the map x → (x-√2)^2 on [√2, 1]: the left endpoint X[1] will be prevfloat(√2)..nextfloat(√2),  but then the map is not monotonic on the whole hull(X[1], X[2]) because it also contains points that lie left of √2. This is a tricky case that must be dealt with.\n\nEnclosures Y[1], Y[2] for f(a), f(b) and increasing may be provided (for instance if we know that Y=(0,1)), otherwise they are computed automatically.\n\n\n\n\n\n","category":"type"},{"location":"Dynamic/#RigorousInvariantMeasures.PwMap","page":"Dynamic","title":"RigorousInvariantMeasures.PwMap","text":"Dynamic based on a piecewise monotonic map.\n\nThe map is defined as T(x) = Ts[k](x) if x in endpointsk endpointsk+1).\n\ny_endpoints (k times 2 matrix) contains the result of applying Ts to the endpoints of each interval. These can be filled in automatically from endpoints, but sometimes they are known to higher accuracy, for instance for x -> mod(3x, 1) we know that it is full-branch exactly. It is assumed that the map will send its domain hull(endpoints[begin],endpoints[end]) into itself.\n\nthe array branches is guaranteed to satisfy branches[i].X[end]==branches[i+1].X[begin]\n\n\n\n\n\n","category":"type"},{"location":"Dynamic/#RigorousInvariantMeasures.PwMap-Tuple{TaylorSeries.Taylor1}","page":"Dynamic","title":"RigorousInvariantMeasures.PwMap","text":"Function call, and Taylor expansion, of a PwMap. Note that this ignores discontinuities; users are free to shoot themselves in the foot and call this on a non-smooth piecewise map. No better solutions for now.\n\n\n\n\n\n","category":"method"},{"location":"Dynamic/#Base.reverse-Tuple{MonotonicBranch}","page":"Dynamic","title":"Base.reverse","text":"Base.reverse(br:MonotonicBranch)\n\n\"Reverses\" the x-axis of a branch: given fab - R, creates a branch with the function g-b-a - R defined as g(x) = f(-x)\n\n\n\n\n\n","category":"method"},{"location":"Dynamic/#RigorousInvariantMeasures.bound_branch_distortion","page":"Dynamic","title":"RigorousInvariantMeasures.bound_branch_distortion","text":"bound_branch_distortion(br::MonotonicBranch; tol = 0.01)\n\nCompute a rigorous bound for the distortion of a branch on an interval I, defaults to the domain of the branch\n\n\n\n\n\n","category":"function"},{"location":"Dynamic/#RigorousInvariantMeasures.branch-Tuple{PwMap, Any}","page":"Dynamic","title":"RigorousInvariantMeasures.branch","text":"function that evaluates the k-th branch of a dynamic on a point x \t(assuming it's in its domain, otherwise ∅)\n\n\n\n\n\n","category":"method"},{"location":"Dynamic/#RigorousInvariantMeasures.branch_inverse_derivative","page":"Dynamic","title":"RigorousInvariantMeasures.branch_inverse_derivative","text":"branch_inverse_derivative(br::MonotonicBranch; tol = 0.01)\n\nCompute a rigorous bound for the inverse_derivative of a branch\n\n\n\n\n\n","category":"function"},{"location":"Dynamic/#RigorousInvariantMeasures.composedPwMap-Tuple{PwMap, PwMap}","page":"Dynamic","title":"RigorousInvariantMeasures.composedPwMap","text":"Create explicitly D1 ∘ D2 as a PwMap; remark that the endpoints \nof D1 must be ordered with respect to the canonical order on R.\n\n\n\n\n\n","category":"method"},{"location":"Dynamic/#RigorousInvariantMeasures.dfly_inf_der","page":"Dynamic","title":"RigorousInvariantMeasures.dfly_inf_der","text":"dfly inequality for maps with infinite derivatives. \n\nThe strategy to compute it follows a variant of Lemma 9.1 in the GMNP paper: \n\nwe find a \"problematic set\" I by taking a small interval of size radius(branch domain)/2^3 around each endpoint with infinite derivative; \nwe find l such that T >= l for each point in I\nwe compute the dfly coefficients as in the lemma.\nwe repeat the computation replacing 2^3 with 2^4, 2^5, ... 2^15 and take the best estimate among these.\n\n\n\n\n\n","category":"function"},{"location":"Dynamic/#RigorousInvariantMeasures.has_infinite_derivative_at_endpoints-Tuple{MonotonicBranch}","page":"Dynamic","title":"RigorousInvariantMeasures.has_infinite_derivative_at_endpoints","text":"has_infinite_derivative_at_endpoints(b::MonotonicBranch)\n\nReturns a pair (left::Bool, right::Bool) that tells if a branch has infinite derivative at any of its endpoints\n\n\n\n\n\n","category":"method"},{"location":"Dynamic/#RigorousInvariantMeasures.has_infinite_derivative_at_endpoints-Tuple{PwMap}","page":"Dynamic","title":"RigorousInvariantMeasures.has_infinite_derivative_at_endpoints","text":"hasinfinitederivativeatendpoints(D::PwMap)\n\nReturns a single bool to tell whether the dynamic has infinite derivative at any of its endpoint\n\n\n\n\n\n","category":"method"},{"location":"Dynamic/#RigorousInvariantMeasures.max_distortion-2","page":"Dynamic","title":"RigorousInvariantMeasures.max_distortion","text":"max_distortion(D::PwMap; tol=1e-3)\n\nCompute a rigorous bound for the distortion of a PwMap\n\nExample\n\njulia> using RigorousInvariantMeasures;\n\njulia> D0 = mod1_dynamic(x->2*x+0.5*x*(1-x), full_branch = true)\nPiecewise-defined dynamic with 2 branches\n\njulia> max_distortion(D0)\n[0.444268, 0.444445]\n\n\n\n\n\n","category":"function"},{"location":"Dynamic/#RigorousInvariantMeasures.max_inverse_derivative-2","page":"Dynamic","title":"RigorousInvariantMeasures.max_inverse_derivative","text":"inverse_derivative(D::PwMap; tol=1e-3)\n\nCompute a rigorous bound for the inverse_derivative of a PwMap\n\n\n\n\n\n","category":"function"},{"location":"Dynamic/#RigorousInvariantMeasures.mod1_dynamic-Tuple{Function}","page":"Dynamic","title":"RigorousInvariantMeasures.mod1_dynamic","text":"mod1_dynamic(f::Function, ε = 0.0; full_branch = false)\n\nUtility constructor for dynamics Mod 1 on the torus [0,1]. We assume that f is monotonic and differentiable, for now (this is not restrictive, for our purposes)\n\nExample\n\njulia> using RigorousInvariantMeasures;\n\njulia> D0 = mod1_dynamic(x->2*x+0.5*x*(1-x), full_branch = true)\nPiecewise-defined dynamic with 2 branches\n\n\n\n\n\n","category":"method"},{"location":"Dynamic/#RigorousInvariantMeasures.preim-2","page":"Dynamic","title":"RigorousInvariantMeasures.preim","text":"Deprecated, but still used in C2Basis\n\n\n\n\n\n","category":"function"},{"location":"Dynamic/#RigorousInvariantMeasures.restrict-Tuple{Any, Any}","page":"Dynamic","title":"RigorousInvariantMeasures.restrict","text":"Intersect an Interval or TaylorSeries with I\n\n\n\n\n\n","category":"method"},{"location":"Dynamic/#Induced-Liverani-Saussol-Vaienti","page":"Dynamic","title":"Induced Liverani Saussol Vaienti","text":"","category":"section"},{"location":"Dynamic/#RigorousInvariantMeasures.ApproxInducedLSV","page":"Dynamic","title":"RigorousInvariantMeasures.ApproxInducedLSV","text":"This class introduces an ApproximatedLSV the induced map for the Liverani-Saussol-Vaienti maps on the interval I = [0.5, 1]. The interval I is then mapped to [0,1]\n\n\n\n\n\n","category":"type"},{"location":"Dynamic/#RigorousInvariantMeasures.ApproxInducedLSV-Tuple{Any, Any}","page":"Dynamic","title":"RigorousInvariantMeasures.ApproxInducedLSV","text":"This constructor builds the induced LSV map on [0.5, 1], truncated with k branches\n\n\n\n\n\n","category":"method"},{"location":"Dynamic/#Base.iterate-Union{Tuple{DualComposedWithDynamic{T, ApproxInducedLSV}}, Tuple{T}, Tuple{DualComposedWithDynamic{T, ApproxInducedLSV}, Any}} where T<:C2Basis","page":"Dynamic","title":"Base.iterate","text":"Return (in an iterator) the pairs (i, (x, |T'(x)|)) where x is a preimage of p[i], which describe the \"dual\" L* evaluation(p[i])\n\n\n\n\n\n","category":"method"},{"location":"Dynamic/#Base.iterate-Union{Tuple{DualComposedWithDynamic{T, ApproxInducedLSV}}, Tuple{T}, Tuple{DualComposedWithDynamic{T, ApproxInducedLSV}, Any}} where T<:Hat","page":"Dynamic","title":"Base.iterate","text":"Return (in an iterator) the pairs (i, (x, |T'(x)|)) where x is a preimage of p[i], which describe the \"dual\" L* evaluation(p[i])\n\n\n\n\n\n","category":"method"},{"location":"Dynamic/#RigorousInvariantMeasures.ShootingLSV","page":"Dynamic","title":"RigorousInvariantMeasures.ShootingLSV","text":"ShootingLSV(n, y, α, rigstep = 10; T = Float64)\n\nThis method returns the preimages of y in the right branch domain after n-1 preimages through the left branch through the LSV map with exponent α\n\n\n\n\n\n","category":"function"},{"location":"NormsOfPowers/#Computing-norms-of-powers","page":"Norms Of Powers","title":"Computing norms of powers","text":"","category":"section"},{"location":"NormsOfPowers/","page":"Norms Of Powers","title":"Norms Of Powers","text":"One of the main tools in our computer aided proofs is  obtaining an estimate on the distance in the weak norm from the ``abstract'' invariant density f and the  approximated invariant density f_k in the weak norm. We refer to","category":"page"},{"location":"NormsOfPowers/","page":"Norms Of Powers","title":"Norms Of Powers","text":"Galatolo S., Monge M., Nisoli I., Poloni F. A general framework for the rigorous computation of invariant densities and the coarse-fine strategy [arXiv:2212.05017]","category":"page"},{"location":"NormsOfPowers/","page":"Norms Of Powers","title":"Norms Of Powers","text":"To obtain this estimate we need to get upper bounds on  L^n_k_U_0_w","category":"page"},{"location":"NormsOfPowers/","page":"Norms Of Powers","title":"Norms Of Powers","text":"The main estimate is  f-f_k_w leq sum_i=0^n L^n_k_U_0_w L-L_k f_sto w","category":"page"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.gamma-Tuple{Any, Integer}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.gamma","text":"γₙ constants for floating point error estimation, as in [Higham, Accuracy and Stability of Numerical Algorithms]\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.infinite_sum_norms-Tuple{Vector}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.infinite_sum_norms","text":"Estimate ||I + Q + Q^2 + … || (infinite sum) using a list of computed norm bounds norms[k] ≥ ||Q^k||.\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.max_nonzeros_per_row-Tuple{SparseArrays.SparseMatrixCSC}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.max_nonzeros_per_row","text":"Returns the maximum number of (structural) nonzeros in a row of A\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.norms_of_powers-Tuple{Basis, Type{<:NormKind}, Integer, DiscretizedOperator, AbstractArray}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.norms_of_powers","text":"Estimates the norms ||Q||, ||Q^2||, ... ||Q^m|| on U^0.\n\nU is the matrix [ones(1,n-1); -I_(n-1,n-1)]. It is currently assumed that f*U==0 (i.e., all elements of f are equal).\n\nf must be an interval vector.\n\nThe following constants may be specified as keyword arguments:\n\nnormQ, normE, normv0, normEF, normIEF, normN\n\notherwise they are computed (which may be slower).\n\ne and f must be specified in case isintegralpreserving==false In case isintegralpreserving is true, they may be specified but they are then ignored.\n\nImplementation note: currently we perform this computation one column at a time, to be able to scale (slowly) to cases with large size; for moderate sizes, it would indeed be better to do the computation all columns at the same time, in BLAS level 3.\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.norms_of_powers_dfly-Tuple{Basis, Dynamic, Any}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.norms_of_powers_dfly","text":"Arrays of bounds to Q^k_w  s = sup_f_w=1 Q^k f_s and to Q^k_w coming theoretically from iterated DFLY inequalities (the \"small matrix method\").\n\nReturns two arrays (strongs, norms) of length m: strongs[k] bounds Q^k f_s, norms[k] bounds Q^k f)\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.norms_of_powers_from_coarser_grid-Tuple{Basis, Basis, Dynamic, Vector, Real}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.norms_of_powers_from_coarser_grid","text":"Estimate norms of powers from those on a coarser grid (see paper for details)\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.norms_of_powers_trivial-Tuple{Real, Integer}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.norms_of_powers_trivial","text":"Array of \"trivial\" bounds for the powers of a DiscretizedOperator (on the whole space) coming from from ||Q^k|| ≤ ||Q||^k\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.refine_norms_of_powers-Tuple{Vector, Any}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.refine_norms_of_powers","text":"Compute better and/or more estimates of power norms using the fact that Q^k+h  Q^k cdot Q^h. This uses multiplicativity, so it will not work for mixed norms, e.g., Q^k_s  w, or M^k_U^0 (unless M preserves U^0, which is the case for Q_U^0).\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/","page":"Norms Of Powers","title":"Norms Of Powers","text":"The methods for systems with noise are the following","category":"page"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.distance_from_invariant_noise-Tuple{Basis, DiscretizedOperator, RigorousInvariantMeasures.NoiseKernel, AbstractVector, Vector}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.distance_from_invariant_noise","text":"Bounds rigorously the distance of w from the fixed point of Q (normalized with integral = 1), using a vector of bounds norms[k] ≥ ||Qh^k|{U_h^0}||.\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.finepowernormboundsnoise-Tuple{Any, Any, Any}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.finepowernormboundsnoise","text":"Uses power norm bounds already computed for a coarse operator to estimate the same norms for a finer operator\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.invariant_vector_noise-Tuple{Basis, DiscretizedOperator, RigorousInvariantMeasures.NoiseKernel}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.invariant_vector_noise","text":"Return a numerical approximation to the (hopefully unique) invariant vector of the dynamic with discretized operator Q.\n\nThe vector is normalized so that integral_covector(B)*w ≈ 1\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.norms_of_powers_abstract_noise-Tuple{Basis, RigorousInvariantMeasures.NoiseKernel, Any}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.norms_of_powers_abstract_noise","text":"Arrays of bounds to ||Q^k||{w → s} = sup{||f||w=1} ||Q^k f||s and to ||Q^k||_{w} coming theoretically from iterated DFLY inequalities (the \"small matrix method\").\n\nReturns two arrays (strongs, norms) of length m: strongs[k] bounds ||Q^k f||_s, norms[k] bounds ||Q^k f||)\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.norms_of_powers_from_coarser_grid_noise-Tuple{Ulam, Ulam, DiscretizedOperator, RigorousInvariantMeasures.NoiseKernel, Vector}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.norms_of_powers_from_coarser_grid_noise","text":"Estimate norms of powers from those on a coarser grid (see paper for details) TODO: Check if it works for other basis types\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.norms_of_powers_noise-Tuple{Ulam, Type{L1}, Integer, DiscretizedOperator, RigorousInvariantMeasures.NoiseKernel, AbstractArray}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.norms_of_powers_noise","text":"Estimates the norms ||Q||, ||Q^2||, ... ||Q^m|| on U^0.\n\nU is the matrix [ones(1,n-1); -I_(n-1,n-1)]. It is currently assumed that f*U==0 (i.e., all elements of f are equal).\n\nf must be an interval vector.\n\nThe following constants may be specified as keyword arguments:\n\nnormQ, normE, normv0, normEF, normIEF, normN\n\notherwise they are computed (which may be slower).\n\ne and f must be specified in case isintegralpreserving==false In case isintegralpreserving is true, they may be specified but they are then ignored.\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.norms_of_powers_trivial_noise-Tuple{Basis, Type{<:NormKind}, DiscretizedOperator, RigorousInvariantMeasures.NoiseKernel, Integer}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.norms_of_powers_trivial_noise","text":"Array of \"trivial\" bounds for the powers of a DiscretizedOperator (on the whole space) coming from from ||Q^k|| ≤ ||Q||^k\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.residualboundnoise-Tuple{Basis, Type{<:NormKind}, DiscretizedOperator, RigorousInvariantMeasures.NoiseKernel, AbstractVector}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.residualboundnoise","text":"Return an upper bound to Q_h*w - w in the given norm\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#Norms","page":"Norms Of Powers","title":"Norms","text":"","category":"section"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.abs_or_mag-Tuple{Number}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.abs_or_mag","text":"'Absolute value' definition that returns mag(I) for an interval and abs(x) for a real\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.z_times_conjz-Tuple{Complex}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.z_times_conjz","text":"Computes a rigorous upper bound for z*z'\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#Norm-bounds","page":"Norms Of Powers","title":"Norm bounds","text":"","category":"section"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.normbound-Tuple{Type{L1}, AbstractVector}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.normbound","text":"Rigorous upper bound on a vector norm. Note that Linf, L1 are the \"analyst's\" norms\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.opnormbound-Union{Tuple{T}, Tuple{Type{L1}, AbstractVecOrMat{T}}} where T","page":"Norms Of Powers","title":"RigorousInvariantMeasures.opnormbound","text":"Certified upper bound to ||A|| (of specified NormKind)\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.opnormbound-Union{Tuple{T}, Tuple{Type{RigorousInvariantMeasures.L2}, Vector{T}}} where T<:Real","page":"Norms Of Powers","title":"RigorousInvariantMeasures.opnormbound","text":"These functions compute a rigorous upper bound for the 2-norm of a vector; we have a specialized version for complex numbers to avoid taking the sqrt root and squaring again \n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#Norm-Cachers","page":"Norms Of Powers","title":"Norm Cachers","text":"","category":"section"},{"location":"NormsOfPowers/","page":"Norms Of Powers","title":"Norms Of Powers","text":"The methods for systems with noise are the following","category":"page"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.NormCacher","page":"Norms Of Powers","title":"RigorousInvariantMeasures.NormCacher","text":"Types to compute norms iteratively by \"adding a column at a time\".\n\n\n\n\n\n","category":"type"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.NormCacher-Union{Tuple{L1}, Tuple{Any, Any}} where L1","page":"Norms Of Powers","title":"RigorousInvariantMeasures.NormCacher","text":"Create a new NormCacher to compute the normbound of the empty matrix with n rows\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.add_column!-Tuple{RigorousInvariantMeasures.NormCacherL1, AbstractVector, Float64}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.add_column!","text":"Update a NormCacher to add one column to the matrix it is computing a norm of. This column may be affected by an error ε (in the same norm).\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.get_norm-Tuple{RigorousInvariantMeasures.NormCacherL1}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.get_norm","text":"Return the norm of the matrix the NormCacher is working on.\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#Convergence-rates-abstract-operator","page":"Norms Of Powers","title":"Convergence rates abstract operator","text":"","category":"section"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.convergencerateabstract-Tuple{Ulam, Dynamic, Any}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.convergencerateabstract","text":"convergencerateabstract(Bas::Ulam, D::Dynamic, norms)\n\nEstimate the strong norm of L^n_U_0_s from norms, the bounds on the weak norm of the discretized operator\n\nL_h^n_U_0_w\n\nThis method was developed in  Stefano Galatolo, Isaia Nisoli, Benoît Saussol. An elementary way to rigorously estimate convergence to equilibrium and escape rates. Journal of Computational Dynamics, 2015, 2 (1) : 51-64. doi: 10.3934/jcd.2015.2.51\n\n\n\n\n\n","category":"method"},{"location":"NormsOfPowers/#RigorousInvariantMeasures.eig_costants_small_matrix-Tuple{Any}","page":"Norms Of Powers","title":"RigorousInvariantMeasures.eig_costants_small_matrix","text":"eig_costants_small_matrix(A)\n\nReturn the dominant eigenvalue and associated left eigenvector of the small matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#Library","page":"Accessories","title":"Library","text":"","category":"section"},{"location":"api/","page":"Accessories","title":"Accessories","text":"","category":"page"},{"location":"api/#Contractors","page":"Accessories","title":"Contractors","text":"","category":"section"},{"location":"api/","page":"Accessories","title":"Accessories","text":"These are interval contractors implemented here; in the future they may be substituted by established libraries, as IntervalRootFinding.jl","category":"page"},{"location":"api/#RigorousInvariantMeasures.preimage_monotonic","page":"Accessories","title":"RigorousInvariantMeasures.preimage_monotonic","text":"Compute the guaranteed interval preimage f⁻¹(y) of a point y ∈ R according to the function f: [a,b] → R.  This preimage is guaranteed to lie inside the real interval x = hull(a,b).\n\nf must be strictly monotonic on [a,b], at least in the sense of MonotonicBranch functions (allowing for uncertainty on the endpoints). f must be differentiable; zero and infinite derivative are allowed.\n\ny1, y2 must be guaranteed to be equal to f(a), f(b) or \"more outside\", so that  y ∉ hull(y1,f(z)) ⟹ f⁻¹(y) ∉ hull(a, z).\n\nStops when the interval reaches a fixed point, when the diameter is smaller than ε, or when max_iter iterations are reached (with an error)\n\n\n\n\n\n","category":"function"},{"location":"api/#RigorousInvariantMeasures.unique_increasing-Tuple{Interval, Interval}","page":"Accessories","title":"RigorousInvariantMeasures.unique_increasing","text":"unique_increasing(a, b)\n\nGiven intervals a, b, returns true if a < b, false if b < a, and raises an error if it is not uniquely determined.\n\n\n\n\n\n","category":"method"},{"location":"api/#Preimages","page":"Accessories","title":"Preimages","text":"","category":"section"},{"location":"api/","page":"Accessories","title":"Accessories","text":"Optimized methods to compute preimages of 1 dimensional maps.","category":"page"},{"location":"api/#RigorousInvariantMeasures.ComposedDynamic","page":"Accessories","title":"RigorousInvariantMeasures.ComposedDynamic","text":"Composed map D1 ∘ D2 ∘ D3. We store with [D1, D2, D3] in this order.\n\nWe overwrite ∘ in base, so one can simply write D1 ∘ D2 or ∘(D1, D2, D3) to construct them.\n\n\n\n\n\n","category":"type"},{"location":"api/#RigorousInvariantMeasures.first_overlapping-Tuple{Any, Any}","page":"Accessories","title":"RigorousInvariantMeasures.first_overlapping","text":"first_overlapping(y, a)\n\nSmallest possible i such that a is in the semi-open interval [y[i], y[i+1]).\n\nThis should work properly even if a, y are intervals; in this case it returns the smallest possible value of i over all possible \"assignments\" of a, y inside those intervals. Assumes y is sorted, i.e., map(y, x->Interval(x).lo) and map(y, x->Interval(x).hi) are sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.last_overlapping-Tuple{Any, Any}","page":"Accessories","title":"RigorousInvariantMeasures.last_overlapping","text":"last_overlapping(y, a)\n\nLargest possible j such that a-ε is in the semi-open interval [y[j], y[j+1]).\n\nThis should work properly even if a, y are intervals; in this case it returns the largest possible value of i over all possible \"assignments\" of a, y inside those intervals. Assumes y is sorted, i.e., map(y, x->Interval(x).lo) and map(y, x->Interval(x).hi) are sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.preimage","page":"Accessories","title":"RigorousInvariantMeasures.preimage","text":"Compute the preimage f⁻¹(y), knowing that it lies inside search_interval.\n\n\n\n\n\n","category":"function"},{"location":"api/#RigorousInvariantMeasures.preimages","page":"Accessories","title":"RigorousInvariantMeasures.preimages","text":"preimages(y, br::MonotonicBranch, ylabel = 1:length(y); ϵ, max_iter)\n\nConstruct preimages of a partition y under a monotonic branch defined on X = (a, b), propagating additional labels ylabel\n\nConstruct preimages of a partition y under a monotonic branch br defined on X = (a, b), propagating additional labels ylabel\n\nIt is assumed that it cannot happen that f(x)  y1.\n\nExtended help\n\nThe sequence y subdivides the y-axis into semi-open intervals [y[l], y[l+1]); each of them is identified by the label ylabel[l]. We construct an increasing sequence  x that splits X (in the x-axis) into semi-open intervals, each of them with f([x[k], x[k+1]) ⊂ [y[l], y[l+1]) for a certain l.  We set xlabel[k] = ylabel[l], and return the pair (x, xlabel).\n\nIt is assumed that it cannot happen that f(x) < y[1].\n\nIn the simplest case where D is full-branch, the points in x are preimages of the points in y, but in the general case they can also include D.endpoints: in general, there may be a certain number of points in y that have no preimage at the beginning and the end of the sequence, because  they fall out of the range R = [f(a), f(b)]. In the worst case, no point has a preimage, because y[i] < R < y[i+1] for some  i (or vice versa with orientations), and in this case we just return the 1-element vectors x = [branch.X[1]] and xlabel = [i].\n\nx[begin] always coincides with branch.X[1], while branch.X[2] is \"the point after x[end]\", and is not stored explicitly in x, for easier composing. In this way x and xlabel have the same length.\n\nThis function fills the array by using a bisection strategy to save computations: if y ∈ [a,b], then f^-1(y) in f^-1(a)f^-1(b) (paying attention to orientation). So we can fill v by filling in first entries v[k+1] with higher dyadic valuation of k.\n\nFor a dynamic with multiple branches, preimages(y, D) is simply the concatenation of x, xlabel for b in all branches. These values still form an increasing sequence that splits X into intervals, each of which is mapped into a different semi-open interval [y[k], y[k+1]).\n\nExample\n\njulia> using RigorousInvariantMeasures\n\njulia> D = mod1_dynamic(x->2x)\nPiecewise-defined dynamic with 2 branches\n\njulia> RigorousInvariantMeasures.preimages(0:0.1:1, D.branches[1]; ϵ = 10^(-15), max_iter = 100)\n(Interval{Float64}[[0, 0], [0.05, 0.0500001], [0.1, 0.100001], [0.149999, 0.15], [0.2, 0.200001], [0.25, 0.25], [0.299999, 0.3], [0.349999, 0.35], [0.4, 0.400001], [0.45, 0.450001]], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n\n\n\n\n","category":"function"},{"location":"api/#RigorousInvariantMeasures.preimages-2","page":"Accessories","title":"RigorousInvariantMeasures.preimages","text":"preimages(y, D::Dynamic, ylabel = 1:length(y), ϵ = 0.0; progress = true)\n\nConstruct preimages of an increasing array y under a dynamic, propagating additional labels `ylabel`\n\n\n\n\n\n","category":"function"},{"location":"api/#RigorousInvariantMeasures.preimages_and_derivatives","page":"Accessories","title":"RigorousInvariantMeasures.preimages_and_derivatives","text":"preimages_and_derivatives(y, br::MonotonicBranch, ylabel = 1:length(y); ϵ, maxiter, left=true)\n\nCompute preimages of D and the derivatives f'(x) in each point.\n\nReturns: x, xlabel, x′\n\nWe combine the two computations in the same function because in this way it can be implemented more efficiently for composed dynamics.\n\nThis assumes that (1) the dynamic is full-branch, and (2) all branches have the same orientation. This is not restrictive because we'll need it only for the Hat assembler (at the moment).\n\nIf left==true, x′ contains the derivatives f'.(x). If right==true, x′ contains derivatives in the right endpoint of each interval of the partition, i.e., for each branch, [f'(x[2]), f'(x[3]), ... f'(x[end]), f'(br.X[2])]. In any case, length(x) == length(x′).\n\n\n\n\n\n","category":"function"},{"location":"api/#RigorousInvariantMeasures.range_estimate_monotone-Tuple{Any, Any}","page":"Accessories","title":"RigorousInvariantMeasures.range_estimate_monotone","text":"Utility function that estimates the range of a monotone function\n\n\n\n\n\n","category":"method"},{"location":"api/#Differentiation-interface","page":"Accessories","title":"Differentiation interface","text":"","category":"section"},{"location":"api/#RigorousInvariantMeasures.check_derivatives","page":"Accessories","title":"RigorousInvariantMeasures.check_derivatives","text":"check_derivatives(f, x=rand())\n\nChecks (using assertions) that the derivatives of f agree (up to the square root of machine precision)  with those computed by TaylorSeries.\n\nThis is a useful sanity check if you redefine derivatives.\n\nThe derivative are checked in a point x (default: rand()), which should be in the domain of f.\n\n```jldoctest\n\njulia> f = @definewithderivatives x->x^2 x->2x x->2;\n\nERROR: LoadError: UndefVarError: @define_with_derivatives not defined\n\nin expression starting at none:1\n\njulia> check_derivatives(f, 0.2)\n\nERROR: UndefVarError: check_derivatives not defined\n\nStacktrace:\n\n[1] top-level scope\n\n@ none:1\n\njulia> g = @definewithderivatives x->x^2 x->2x x->3;\n\nERROR: LoadError: UndefVarError: @define_with_derivatives not defined\n\nin expression starting at none:1\n\njulia> check_derivatives(g, 0.2)\n\nERROR: UndefVarError: check_derivatives not defined\n\nStacktrace:\n\n[1] top-level scope\n\n@ none:1\n\n```\n\n\n\n\n\n","category":"function"},{"location":"api/#RigorousInvariantMeasures.distortion-Tuple{Any, Any}","page":"Accessories","title":"RigorousInvariantMeasures.distortion","text":"The distortion of f is f'' / (f')^2.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.inverse_derivative-Tuple{Any, Any}","page":"Accessories","title":"RigorousInvariantMeasures.inverse_derivative","text":"The inverse_derivative of f is 1/f'.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.value_and_derivative-Tuple{Any, Any}","page":"Accessories","title":"RigorousInvariantMeasures.value_and_derivative","text":"value_and_derivative(f, x)\n\nEvaluate f(x) and f'(x) at the same time.  We define a single method to do this because often there are shared subexpressions between a function and its derivatives, or they are computed together by automatic differentiation packages, so this is often more efficient than having two separate functions for f and f' and calling them separately.\n\nThe generic implementation uses TaylorSeries to compute derivatives. It can be overwritten for individual functions:\n\nf = x -> x^2\nvalue_and_derivative(f::typeof(f), x) = (x^2, 2x)\n\nSee @definewithderivatives to define derivatives with three separate expressions.\n\nRemark: when specializing derivatives by hand, always specialize the two-argoment functions  (e.g., value_and_derivative(f, x)) rather than the one-parameter ones  (e.g., value_and_derivative(f)), since the latter are defined generically in terms of the former.\n\nRemark: tricky point that can cause subtle bugs: functions created in the same line-of-code will often have the same type; so for instance\n\n```jldoctest\n\njulia> fs = [x -> k*x for k in 1:3];  # the three elements here have the same type\n\njulia> typeof(fs[1]) == typeof(fs[3])\n\ntrue\n\njulia> RigorousInvariantMeasures.derivative(f::typeof(fs[1]), x) = 1;\n\njulia> RigorousInvariantMeasures.derivative(f::typeof(fs[2]), x) = 2;\n\njulia> RigorousInvariantMeasures.derivative(f::typeof(fs[3]), x) = 3;\n\njulia> RigorousInvariantMeasures.derivative(fs[1], 0.5)  # this returns 3, not 1\n\n3\n\n```\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.value_derivative_and_second_derivative-Tuple{Any, Any}","page":"Accessories","title":"RigorousInvariantMeasures.value_derivative_and_second_derivative","text":"value_derivative_and_second_derivative(f, x)\n\nGeneric method to evaluate f(x), f'(x) and f''(x) at the same time.\n\nSee value_and_derivative for more detail.\n\n\n\n\n\n","category":"method"},{"location":"api/#RigorousInvariantMeasures.@define_with_derivatives-Tuple{Any, Any, Any}","page":"Accessories","title":"RigorousInvariantMeasures.@define_with_derivatives","text":"f = @define_with_derivatives(ex1, ex2, ex3)\n\nDeclares a new function f, and redefines the various functions related to derivatives so that its derivatives are computed with the given expressions.\n\n```jldoctest\n\njulia> f = @definewithderivatives x->x^2 x->2x x->2;\n\nERROR: LoadError: UndefVarError: @define_with_derivatives not defined\n\nin expression starting at none:1\n\njulia> valueandderivative(f, 45)\n\nERROR: UndefVarError: value_and_derivative not defined\n\nStacktrace:\n\n[1] top-level scope\n\n@ none:1\n\n```\n\nNote that the three macro parameters are separated just by spaces (no commas or parentheses)\n\n```jldoctest\n\njulia> g = @definewithderivatives x->12 x->34 x->56;\n\nERROR: LoadError: UndefVarError: @define_with_derivatives not defined\n\nin expression starting at none:1\n\njulia> valuederivativeandsecondderivative(g, -23.5)\n\nERROR: UndefVarError: value_derivative_and_second_derivative not defined\n\nStacktrace:\n\n[1] top-level scope\n\n@ none:1\n\n```\n\nThis is provided for convenience, but note that in many cases one can find  common subexpressions in a function and its derivatives; hence it is more efficient to define the two functions separately.\n\nIf you define derivatives in this way, it is recommended to run check_derivatives to ensure that you did not make any mistakes (e.g., forgetting a factor 2). We do not run it automatically because that would require knowing a valid x in the domain of f.\n\n\n\n\n\n","category":"macro"},{"location":"Basis/","page":"Basis","title":"Basis","text":"We present some of the basis already implemented in the package","category":"page"},{"location":"Basis/#Abstract-basis","page":"Basis","title":"Abstract basis","text":"","category":"section"},{"location":"Basis/#RigorousInvariantMeasures.AverageZero","page":"Basis","title":"RigorousInvariantMeasures.AverageZero","text":"AverageZero{B<:Basis}\n\nYield a basis of the space of average zero vectors\n\n\n\n\n\n","category":"type"},{"location":"Basis/#RigorousInvariantMeasures.Dual","page":"Basis","title":"RigorousInvariantMeasures.Dual","text":"Replacement of DualComposedWithDynamic.\n\n\n\n\n\n","category":"type"},{"location":"Basis/#RigorousInvariantMeasures.aux_normalized_projection_error-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.aux_normalized_projection_error","text":"aux_normalized_projection_error(B::Basis)\n\nReturn a constant Eh (typically scales as h ~ 1/n) such that \n\nP_h fleq f+ Eh * f_s\n\nMust be rounded up correctly!\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.aux_weak_bound-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.aux_weak_bound","text":"aux_weak_bound(B::Basis)\n\nReturn a constant M₂ such that for a vector v  Uₕ\n\nvleq M_2v\n\nMust be rounded up correctly!\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.bound_linalg_norm_L1_from_weak-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.bound_linalg_norm_L1_from_weak","text":"bound_linalg_norm_L1_from_weak(B::Basis)\n\nReturn a constant A such that for a vector v  Uₕ \n\nv_1leq Av\n\nMust be rounded up correctly!\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.bound_linalg_norm_L∞_from_weak-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.bound_linalg_norm_L∞_from_weak","text":"bound_linalg_norm_L∞_from_weak(B::Basis)\n\nReturn a constant A such that for a vector v  Uₕ  ||v||_\\infty \\leq A||v|| Must be rounded up correctly!\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.bound_weak_norm_abstract","page":"Basis","title":"RigorousInvariantMeasures.bound_weak_norm_abstract","text":"bound_weak_norm_abstract(B::Basis, D=nothing; dfly_coefficients=nothing)\n\nReturns an a priori bound on the weak norm of the abstract operator L\n\n\n\n\n\n","category":"function"},{"location":"Basis/#RigorousInvariantMeasures.bound_weak_norm_from_linalg_norm-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.bound_weak_norm_from_linalg_norm","text":"bound_weak_norm_from_linalg_norm(B::Basis)\n\nReturn constants W₁, W₂ such that for a vector v  Uₕ \n\nvleq W_1v_1+W_2v_infty\n\nMust be rounded up correctly!\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.evaluate-Tuple{Basis, Any, Any}","page":"Basis","title":"RigorousInvariantMeasures.evaluate","text":"evaluate(B::Basis, i, x)\n\nEvaluate the i-th basis element at x\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.evaluate_integral-Tuple{Basis, Any}","page":"Basis","title":"RigorousInvariantMeasures.evaluate_integral","text":"evaluate_integral(B::Basis, i; T = Float64)\n\nValue of the integral on [0,1] of the i-th basis element\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.integral-Tuple{Basis, Any}","page":"Basis","title":"RigorousInvariantMeasures.integral","text":"integral(B::Basis, v; T = Float64)\n\nReturn the integral of the function with coefficients v in the basis B \n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.integral_covector-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.integral_covector","text":"integral_covector(B::Basis)\n\nReturn a covector that represents the integral in the basis B\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.invariant_measure_strong_norm_bound-Tuple{Basis, Dynamic}","page":"Basis","title":"RigorousInvariantMeasures.invariant_measure_strong_norm_bound","text":"invariant_measure_strong_norm_bound(B::Basis, D::Dynamic)\n\nBounds u_s, where u is the invariant measure normalized with  i(u)=1.\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.is_integral_preserving-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.is_integral_preserving","text":"is_integral_preserving(B::Basis)\n\nIntegral-preserving discretizations may specialize this to \"true\"\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.is_refinement-Tuple{Basis, Basis}","page":"Basis","title":"RigorousInvariantMeasures.is_refinement","text":"is_refinement(Bfine::Basis, Bcoarse::Basis)\n\nCheck if Bfine is a refinement of Bcoarse\n\nExample\n\njulia> using RigorousInvariantMeasures\n\njulia> B = Ulam(1024)\nUlam{LinRange{Float64, Int64}}(LinRange{Float64}(0.0, 1.0, 1025))\n\njulia> Bfine = Ulam(2048)\nUlam{LinRange{Float64, Int64}}(LinRange{Float64}(0.0, 1.0, 2049))\n\njulia> is_refinement(Bfine, B)\ntrue\n\njulia> Bfine = Ulam(2049)\nUlam{LinRange{Float64, Int64}}(LinRange{Float64}(0.0, 1.0, 2050))\n\njulia> is_refinement(Bfine, B)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.one_vector-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.one_vector","text":"one_vector(B::Basis)\n\nVector that represents the function 1 in the basis B\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.strong_norm-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.strong_norm","text":"strong_norm(B::Basis)\n\nReturn the type of the strong norm of the basis\n\nExample\n\njulia> using RigorousInvariantMeasures\n\njulia> B = Ulam(1024)\nUlam{LinRange{Float64, Int64}}(LinRange{Float64}(0.0, 1.0, 1025))\n\njulia> strong_norm(B)\nTotalVariation\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.strong_weak_bound-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.strong_weak_bound","text":"strong_weak_bound(B::Basis)\n\nReturn a constant M₁n such that for a vector v  Uₕ \n\nv_sleq M1n*v\n\nMust be rounded up correctly!\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.weak_by_strong_and_aux_bound-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.weak_by_strong_and_aux_bound","text":"Return constants S₁ S₂ such that for a vector v  Uₕ \n\nvleq S_1v_s+S_2v\n\nMust be rounded up correctly!\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.weak_norm-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.weak_norm","text":"weak_norm(B::Basis)\n\nReturn the type of the weak norm of the basis\n\nExample\n\njulia> using RigorousInvariantMeasures\n\njulia> B = Ulam(1024)\nUlam{LinRange{Float64, Int64}}(LinRange{Float64}(0.0, 1.0, 1025))\n\njulia> weak_norm(B)\nL1\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.weak_projection_error-Tuple{Basis}","page":"Basis","title":"RigorousInvariantMeasures.weak_projection_error","text":"weak_projection_error(B::Basis)\n\nReturn a constant Kh (typically scales as h ~ 1/n) such that \n\nP_h f-fleq Kh f_s\n\nMust be rounded up correctly! This function is not exported explictly but is used in all the estimates.\n\nExample\n\njulia> using RigorousInvariantMeasures;\n\njulia> B = Ulam(1024)\nUlam{LinRange{Float64, Int64}}(LinRange{Float64}(0.0, 1.0, 1025))\n\njulia> RigorousInvariantMeasures.weak_projection_error(B)\n0.00048828125\n\n\n\n\n\n","category":"method"},{"location":"Basis/#The-Ulam-basis","page":"Basis","title":"The Ulam basis","text":"","category":"section"},{"location":"Basis/","page":"Basis","title":"Basis","text":"The Ulam basis associated to a finite partition \\{0 = x_0, \\ldots, x_N = 1\\}, is given by  the collection of characteristic functions \\chi_{[x_i,x_{i+1})} for i in 0, \\ldots, N.","category":"page"},{"location":"Basis/","page":"Basis","title":"Basis","text":"The regularity seminorm associated to this basis is the Variation seminorm,  \\textrm{Var}(\\phi) = \\sup_{\\mathcal{P}} \\sum |\\phi(z_{i+1})-\\phi(z_i)|","category":"page"},{"location":"Basis/#RigorousInvariantMeasures.Ulam","page":"Basis","title":"RigorousInvariantMeasures.Ulam","text":"Ulam\n\nUlam basis on [0,1] associated to the partition p = x_0 = 0 x_1 ldots x_n=1\n\n\n\n\n\n","category":"type"},{"location":"Basis/#RigorousInvariantMeasures.Ulam-Tuple{Integer}","page":"Basis","title":"RigorousInvariantMeasures.Ulam","text":"Ulam(n::Integer)\n\nEquispaced Ulam basis on [0,1] of size n\n\n\n\n\n\n","category":"method"},{"location":"Basis/#Base.getindex-Tuple{Ulam, Int64}","page":"Basis","title":"Base.getindex","text":"Base.getindex(B::Ulam, i::Int)\n\nReturns the i-th element of the Ulam basis as a function.\n\nExample\n\njulia> using RigorousInvariantMeasures\n\njulia> B = Ulam(16)\nUlam{LinRange{Float64, Int64}}(LinRange{Float64}(0.0, 1.0, 17))\n\njulia> B[1](1/32)\n1\n\njulia> B[2](1/32)\n0\n\n\n\n\n\n","category":"method"},{"location":"Basis/#Base.iterate-Union{Tuple{AverageZero{Ulam{T}}}, Tuple{T}, Tuple{AverageZero{Ulam{T}}, Any}} where T","page":"Basis","title":"Base.iterate","text":"iterate(S::AverageZero{Ulam{T}}, state = 1) where{T}\n\nReturn the elements of the basis of average 0 functions in the Ulam  Basis\n\n\n\n\n\n","category":"method"},{"location":"Basis/#Base.iterate-Union{Tuple{ProjectDualElement{BT, DT}}, Tuple{DT}, Tuple{BT}, Tuple{ProjectDualElement{BT, DT}, Any}} where {BT<:Ulam, DT}","page":"Basis","title":"Base.iterate","text":"Given a preimage of an interval I_i, this iterator returns its relative intersection with all the elements of the Ulam basis that have nonzero intersection with it\n\n\n\n\n\n","category":"method"},{"location":"Basis/#Base.length-Tuple{Ulam}","page":"Basis","title":"Base.length","text":"Base.length(B::Ulam)\n\nReturns the size of the Ulam basis (the size of the underlying vector -1)\n\n\n\n\n\n","category":"method"},{"location":"Basis/#Base.length-Union{Tuple{AverageZero{Ulam{T}}}, Tuple{T}} where T","page":"Basis","title":"Base.length","text":"Base.length(S::AverageZero{Ulam})\n\nReturn the size of the Average Zero space\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.nonzero_on-Tuple{Ulam, Any}","page":"Basis","title":"RigorousInvariantMeasures.nonzero_on","text":"nonzero_on(B::Ulam, (a, b))\n\nReturns the indices of the elements of the Ulam basis that intersect with the interval y We do not assume an order of a and b; this should not matter unless the preimages are computed with very low accuracy. We assume, though, that y comes from the (possibly inexact) numerical approximation of an interval in 01, i.e., we restrict to y cap 01\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.relative_measure-Tuple{Tuple{Interval, Interval}, Tuple{Interval, Interval}}","page":"Basis","title":"RigorousInvariantMeasures.relative_measure","text":"relative_measure((a,b)::Tuple{<:Interval,<:Interval}, (c,d)::Tuple{<:Interval,<:Interval})\n\nRelative measure of the intersection of (a,b) wrt the whole interval (c,d) Assumes that a,b and c,d are sorted correctly\n\n\n\n\n\n","category":"method"},{"location":"Basis/#The-hat-basis-on-S1","page":"Basis","title":"The hat basis on S^1","text":"","category":"section"},{"location":"Basis/#RigorousInvariantMeasures.Hat","page":"Basis","title":"RigorousInvariantMeasures.Hat","text":"Hat\n\nThis type represents a Hat basis on S^1. It contains a vector with the midpoints of the hats.\n\n\n\n\n\n","category":"type"},{"location":"Basis/#RigorousInvariantMeasures.Hat-Tuple{Integer}","page":"Basis","title":"RigorousInvariantMeasures.Hat","text":"Hat(n::Integer)\n\nThis constructs a Hat basis on S^1 on equispaced points\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.HatFunctionOnTorus","page":"Basis","title":"RigorousInvariantMeasures.HatFunctionOnTorus","text":"HatFunctionOnTorus\n\nHat function (on the torus)\n\nThis is a piecewise linear function such that: \tf(x) = 0 if x <= lo \tf(mi) = 1 \tf(x) = 0 if x >= ho\n\n\n\n\n\n","category":"type"},{"location":"Basis/#RigorousInvariantMeasures.HatFunctionOnTorus-Union{Tuple{RigorousInvariantMeasures.IntervalOnTorus}, Tuple{T}} where T","page":"Basis","title":"RigorousInvariantMeasures.HatFunctionOnTorus","text":"Evaluate a HatFunctionOnTorus correctly on an IntervalOnTorus\n\nAssumption: this is only called on functions defined on our partition, so either mi==0, hi==0, or the three values are in increasing order\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.IntervalOnTorus","page":"Basis","title":"RigorousInvariantMeasures.IntervalOnTorus","text":"IntervalOnTorus\n\nA separate type for intervals on the torus (mod 1) to \"remind\" us of the quotient\n\nThe interval is normalized in the constructor: the caller may assume that\n\n0 <= i.lo < 1\ni.hi < i.lo + 1 OR i==Interval(0,1)\n\n\n\n\n\n","category":"type"},{"location":"Basis/#Base.getindex-Tuple{Hat, Int64}","page":"Basis","title":"Base.getindex","text":"Base.getindex(B::Hat, i::Int)\n\nMake so that B[j] returns a HatFunctionOnTorus with the j-th basis element\n\n\n\n\n\n","category":"method"},{"location":"Basis/#Base.iterate-Union{Tuple{ProjectDualElement{T, DT}}, Tuple{DT}, Tuple{T}, Tuple{ProjectDualElement{T, DT}, Any}} where {T<:Hat, DT}","page":"Basis","title":"Base.iterate","text":"Given a preimage y of a point x, this iterator returns phi_j(y)T(y)\n\n\n\n\n\n","category":"method"},{"location":"Basis/#Base.length-Union{Tuple{Hat{T}}, Tuple{T}} where T","page":"Basis","title":"Base.length","text":"Base.length(B::Hat{T})\n\nReturn the size of the Hat basis\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.nonzero_on-Tuple{Hat, Any}","page":"Basis","title":"RigorousInvariantMeasures.nonzero_on","text":"nonzero_on(B::Hat, dual_element)\n\nReturn the range of indices of the elements of the basis whose support intersects with the given dual element (i.e., a pair (y, absT')). The range may end with length(B)+1; this must be interpreted \"mod length(B)\": it means that it intersects with the hat function peaked in 0 as well (think for instance y = 0.9999).\n\n\n\n\n\n","category":"method"},{"location":"Basis/#The-hat-basis-on-[0,1]","page":"Basis","title":"The hat basis on 01","text":"","category":"section"},{"location":"Basis/#RigorousInvariantMeasures.HatFunction","page":"Basis","title":"RigorousInvariantMeasures.HatFunction","text":"Hat function (on the reals)\n\nThis is a piecewise linear function such that: \tf(x) = 0 if x <= lo \tf(mi) = 1 \tf(hi)\n\n\n\n\n\n","category":"type"},{"location":"Basis/#RigorousInvariantMeasures.HatFunction-Union{Tuple{T}, Tuple{S}} where {S<:Number, T}","page":"Basis","title":"RigorousInvariantMeasures.HatFunction","text":"Evaluate a HatFunction (on the real line).\n\nMust work correctly when S is an interval.\n\n\n\n\n\n","category":"method"},{"location":"Basis/#Base.getindex-Tuple{HatNP, Int64}","page":"Basis","title":"Base.getindex","text":"Base.getindex(B::HatNP, i::Int)\n\nmakes so that B[j] returns a HatFunction with the j-th basis element\n\n\n\n\n\n","category":"method"},{"location":"Basis/#Base.iterate-Union{Tuple{ProjectDualElement{T, DT}}, Tuple{DT}, Tuple{T}, Tuple{ProjectDualElement{T, DT}, Any}} where {T<:HatNP, DT}","page":"Basis","title":"Base.iterate","text":"Given a preimage y of a point x, this iterator returns \\phi_j(y)/T'(y)\n\n\n\n\n\n","category":"method"},{"location":"Basis/#Base.length-Union{Tuple{HatNP{T}}, Tuple{T}} where T","page":"Basis","title":"Base.length","text":"Base.length(B::HatNP)\n\nReturn the size of the HatNP basis\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.nonzero_on-Tuple{HatNP, Any}","page":"Basis","title":"RigorousInvariantMeasures.nonzero_on","text":"Return the range of indices of the elements of the basis whose support intersects with the given dual element (i.e., a pair (y, absT')). The range may end with length(B)+1; this must be interpreted \"mod length(B)\": it means that it intersects with the hat function peaked in 0 as well (think for instance y = 0.9999).\n\n\n\n\n\n","category":"method"},{"location":"Basis/#The-C2-basis","page":"Basis","title":"The C2 basis","text":"","category":"section"},{"location":"Basis/#RigorousInvariantMeasures.EquispacedPartitionInterval","page":"Basis","title":"RigorousInvariantMeasures.EquispacedPartitionInterval","text":"Equispaced partition of size n of [0,1]\n\n\n\n\n\n","category":"type"},{"location":"Basis/#Base.iterate-Union{Tuple{DualComposedWithDynamic{T, Dynamic}}, Tuple{T}, Tuple{DualComposedWithDynamic{T, Dynamic}, Any}} where T<:C2Basis","page":"Basis","title":"Base.iterate","text":"Return (in an iterator) the pairs (i, (x, |T'(x)|)) where x is a preimage of p[i], which describe the \"dual\" L* evaluation(p[i])\n\n\n\n\n\n","category":"method"},{"location":"Basis/#Base.iterate-Union{Tuple{ProjectDualElement{T}}, Tuple{T}, Tuple{ProjectDualElement{T}, Any}} where T<:C2Basis","page":"Basis","title":"Base.iterate","text":"Given a preimage y of a point x, this iterator returns phi_j(y)T(y)\n\n\n\n\n\n","category":"method"},{"location":"Basis/#Base.length-Tuple{C2Basis}","page":"Basis","title":"Base.length","text":"Return the size of the C2 basisBase.length(S::AverageZero) = length(S.basis)-1\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.nonzero_on-Tuple{C2Basis, Any}","page":"Basis","title":"RigorousInvariantMeasures.nonzero_on","text":"Return the range of indices of the elements of the basis whose support intersects with the given dual element (i.e., a pair (y, absT', derder)).\n\n\n\n\n\n","category":"method"},{"location":"Basis/#The-Chebyshev-basis","page":"Basis","title":"The Chebyshev basis","text":"","category":"section"},{"location":"Basis/#Base.getindex-Tuple{Chebyshev, Int64}","page":"Basis","title":"Base.getindex","text":"Base.getindex(B::Chebyshev, i::Int)\n\nMake so that B[j] returns a HatFunctionOnTorus with the j-th basis element\n\n\n\n\n\n","category":"method"},{"location":"Basis/#Base.length-Tuple{Chebyshev}","page":"Basis","title":"Base.length","text":"Return the size of the Chebyshev basis\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures._eval_T-Union{Tuple{T}, Tuple{Any, Array{T}}} where T","page":"Basis","title":"RigorousInvariantMeasures._eval_T","text":"_eval_T\n\nEval the Chebyshev polynomial up to degree n on an array of  points in [-1, 1].\n\nNot satisfactory, the intervals explode\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.eval_Clenshaw_BackwardFirst-Union{Tuple{T}, Tuple{S}, Tuple{Array{Interval{S}, 1}, Interval{T}}} where {S, T}","page":"Basis","title":"RigorousInvariantMeasures.eval_Clenshaw_BackwardFirst","text":"eval_Clenshaw_BackwardFirst\n\nEval a polynomial in Chebyshev basis, ClenshawBackward, using ball arithmetic Following Viviane Ledoux, Guillaume Moroz  \"Evaluation of Chebyshev polynomials on intervals andapplication to root finding\"\n\n\n\n\n\n","category":"method"},{"location":"Basis/#RigorousInvariantMeasures.get_norm-Tuple{RigorousInvariantMeasures.NormCacherC1}","page":"Basis","title":"RigorousInvariantMeasures.get_norm","text":"Return the norm of the matrix the NormCacher is working on.\n\n\n\n\n\n","category":"method"},{"location":"Basis/#Common-Fourier-interface","page":"Basis","title":"Common Fourier interface","text":"","category":"section"},{"location":"Basis/#Base.getindex-Tuple{Fourier, Int64}","page":"Basis","title":"Base.getindex","text":"Make so that B[j] returns the basis function of coordinate j\n\n\n\n\n\n","category":"method"},{"location":"Basis/#The-Fourier-Adjoint-basis","page":"Basis","title":"The Fourier Adjoint basis","text":"","category":"section"},{"location":"Basis/#Base.length-Tuple{FourierAdjoint}","page":"Basis","title":"Base.length","text":"Return the size of the Fourier basis\n\n\n\n\n\n","category":"method"},{"location":"Basis/#The-Fourier-Analytic-basis","page":"Basis","title":"The Fourier Analytic basis","text":"","category":"section"},{"location":"Basis/#RigorousInvariantMeasures.strong_weak_bound-Tuple{FourierAnalytic}","page":"Basis","title":"RigorousInvariantMeasures.strong_weak_bound","text":"Return the weak-strong norm bound when restricted on the finite dimensional subspace We use here sum_i=-K^K (g_iexp^2pi eta i)^2 leq sum_-K^K g_i^2 sum_-K^K exp^2(2pi eta i) leq g_2 2frac1-exp^2K+2(2pi eta i)1-exp^2(2pi eta i) \n\n\n\n\n\n","category":"method"},{"location":"implementingnewbasis/#Implementing-a-new-basis","page":"Implementing a new basis","title":"Implementing a new basis","text":"","category":"section"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"In the file [BasisDefinition.jl] are declared the necessary methods  for the implementation of a new basis to work with the coarse-fine framework.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"The new basis type has to be defined as a subtype of the abstract type Basis.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"struct NewBasis <: Basis\n    # base specific code\nend","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"If possible, implement some utility constructors like  NewBasis(n) to initialize a basis of size n.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"To compute the operator through the generic assembler we implement a NewBasisDual <: Dual object that contains the data  necessary to compute the raw data necessary  to compute the entries of the operator, e.g., in the Ulam basis case, it contains three objects. One is a vector of preimages, which contains  all the preimages T_i^-1(x_j) of the elements of the partition  through the different branches T_i of the map, a second vector that contains the labels associated to these points, i.e., j. The layout is like this:","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"T_1^-1(x_1) ldots T_1^-1(x_n) T_2^-1(x_1) ldots ","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"1 ldots n 1 ldots","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"In the case of the Hat basis, there is a third vector  that contains the derivative at the preimages.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"Now it is necessary to define an iterator on the Dual object, by defining  Base.iterate(dual::NewBasisDual, state = 1). This iterator returns the data necessary for the computation; in the case of the Ulam basis, it returns the label and the preimages of the endpoints  of one connected component of the preimage of an interval.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"We take now the elements returned by the iteration  on NewBasisDual and for each one of them we define  construct an object of type ProjectDualElement. This object contains information on which elements of the basis we need to compute corresponding to the dual element, computed through the BasisDefinition.nonzero_on function. In the Ulam case, it computes which intervals have nonempty intersection with the interval defined in  the dual element.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"Now, we need to define an iterator on the ProjectDualElement object that for all indexes associated to the dual element computes the  value of the coefficient of the operator.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"Resuming:","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"define a NewBasis structure\ndefine a NewDual structure and the iterator on it\ndefine a BasisDefinition.nonzero_on function which allows the construction of ProjectDualElement objects\ndefine the iterator on ProjectDualElementthat returns ","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"the coefficients","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"To allow the coarse-fine method to work out of the box, we need to implement different functions that return bound for the various constants. A comprehensive list is contained in the file [BasisDefinition.jl].","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"The first thing we need to define are the norm types that correspond to our approximation scheme.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"struct StrongNormNewBasis <: NormKind end\nstruct WeakNormNewBasis <: NormKind end","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"They must be specialized to our new basis.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"strong_norm(B::NewBasis) = StrongNormNewBasis\nweak_projection_error(B::NewBasis)","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"The needed constants and functions are listed there. If not defined, the compiler will call the most  general version that applies, the one in BasisDefinition, that throws an error.","category":"page"},{"location":"implementingnewbasis/","page":"Implementing a new basis","title":"Implementing a new basis","text":"In principle, it is possible to define a new basis by  starting with only the struct, running the code and looking at the error codes julia is throwing, that correspond to the non implemented functions.","category":"page"},{"location":"GenericEstimate/#Generic-estimate","page":"Generic estimate interface","title":"Generic estimate","text":"","category":"section"},{"location":"GenericEstimate/","page":"Generic estimate interface","title":"Generic estimate interface","text":"This is the generic estimator interface and types; the idea is that the method are dispatched based on the basis type and the dynamic type.","category":"page"},{"location":"GenericEstimate/#RigorousInvariantMeasures.CoarseGridQuantities","page":"Generic estimate interface","title":"RigorousInvariantMeasures.CoarseGridQuantities","text":"Struct that encapsulates the additional quantities needed on the coarse basis for a two-grid estimate, or on the (only) basis for a one-grid estimate.  It is meant as an intermediate quantity that can be saved on the disk to avoid recomputing Q all the times.\n\n\n\n\n\n","category":"type"},{"location":"GenericEstimate/#RigorousInvariantMeasures.FineGridQuantities","page":"Generic estimate interface","title":"RigorousInvariantMeasures.FineGridQuantities","text":"Struct that encapsulates all the quantities computed from the fine basis that are needed in the two-grid estimate. It is meant as an intermediate quantity that can be saved on the disk to avoid recomputing Q all the times\n\n\n\n\n\n","category":"type"},{"location":"GenericEstimate/#RigorousInvariantMeasures.compute_coarse_grid_quantities-Tuple{Any, Any}","page":"Generic estimate interface","title":"RigorousInvariantMeasures.compute_coarse_grid_quantities","text":"Compute FineGridQuantities and CoarseGridQuantities, given a function f(n) that computes B, D, Q = f(n)\n\n\n\n\n\n","category":"method"},{"location":"GenericEstimate/#RigorousInvariantMeasures.compute_fine_grid_quantities-Tuple{Any, Any}","page":"Generic estimate interface","title":"RigorousInvariantMeasures.compute_fine_grid_quantities","text":"Compute FineGridQuantities, given a function f(n) that computes B, D, Q = f(n)\n\n\n\n\n\n","category":"method"},{"location":"GenericEstimate/#RigorousInvariantMeasures.distance_from_invariant-Tuple{Basis, Dynamic, Union{Nothing, DiscretizedOperator}, AbstractVector, Vector}","page":"Generic estimate interface","title":"RigorousInvariantMeasures.distance_from_invariant","text":"Bounds rigorously the distance of w from the fixed point of Q (normalized with integral = 1), using a vector of bounds norms[k] ≥ ||Qh^k|{U_h^0}||. If ε₁ and normQ are given, then Q can be omitted\n\n\n\n\n\n","category":"method"},{"location":"GenericEstimate/#RigorousInvariantMeasures.finepowernormbounds-NTuple{4, Any}","page":"Generic estimate interface","title":"RigorousInvariantMeasures.finepowernormbounds","text":"Uses power norm bounds already computed for a coarse operator to estimate the same norms for a finer operator\n\n\n\n\n\n","category":"method"},{"location":"GenericEstimate/#RigorousInvariantMeasures.invariant_vector-Tuple{Basis, DiscretizedOperator}","page":"Generic estimate interface","title":"RigorousInvariantMeasures.invariant_vector","text":"Return a numerical approximation to the (hopefully unique) invariant vector of the dynamic with discretized operator Q.\n\nThe vector is normalized so that integral_covector(B)*w ≈ 1\n\n\n\n\n\n","category":"method"},{"location":"GenericEstimate/#RigorousInvariantMeasures.one_grid_estimate-Tuple{RigorousInvariantMeasures.CoarseGridQuantities, RigorousInvariantMeasures.FineGridQuantities}","page":"Generic estimate interface","title":"RigorousInvariantMeasures.one_grid_estimate","text":"Compute a one-grid error estimate.\n\nThe first return argument is the error, the second is the time breakdown according to [\"dfly\", \"assembling\", \"eigen\", \"norms\", \"error\"].  (The sum of that vector is the total time taken)\n\n\n\n\n\n","category":"method"},{"location":"GenericEstimate/#RigorousInvariantMeasures.powernormbounds-NTuple{4, Any}","page":"Generic estimate interface","title":"RigorousInvariantMeasures.powernormbounds","text":"Uses different strategies to compute power norm bounds.\n\nIf specified, m norms of powers are estimated computationally, and then m_extend norms are obtained with a cheaper refinement process. Otherwise these numbers are selected automatically.\n\nA vector of length mextend is returned, such that norms[k] ≥ ||Qh^k|{Uh^0}||\n\n\n\n\n\n","category":"method"},{"location":"GenericEstimate/#RigorousInvariantMeasures.powernormbounds-Tuple{Any, Any}","page":"Generic estimate interface","title":"RigorousInvariantMeasures.powernormbounds","text":"Computes bounds for norms of powers, taking (optionally) minimum values for the number of norms to compute\n\n\n\n\n\n","category":"method"},{"location":"GenericEstimate/#RigorousInvariantMeasures.residualbound-Tuple{Basis, Type{<:NormKind}, DiscretizedOperator, AbstractVector}","page":"Generic estimate interface","title":"RigorousInvariantMeasures.residualbound","text":"Return an upper bound to Q_h*w - w in the given norm\n\n\n\n\n\n","category":"method"},{"location":"GenericEstimate/#RigorousInvariantMeasures.two_grid_estimate-Tuple{RigorousInvariantMeasures.CoarseGridQuantities, RigorousInvariantMeasures.FineGridQuantities}","page":"Generic estimate interface","title":"RigorousInvariantMeasures.two_grid_estimate","text":"Compute a two-grid error estimate.\n\nThe first return argument is the error, the second is the time breakdown according to [\"dfly\", \"coarse\", \"assembling\", \"eigen\", \"norms\", \"error\"].  (The sum of that vector is the total time taken)\n\n\n\n\n\n","category":"method"},{"location":"GenericEstimate/#DFLY","page":"Generic estimate interface","title":"DFLY","text":"","category":"section"},{"location":"GenericEstimate/#RigorousInvariantMeasures.dfly-Tuple{Type{<:NormKind}, Type{<:NormKind}, Dynamic}","page":"Generic estimate interface","title":"RigorousInvariantMeasures.dfly","text":"(A, B) = dfly(strongnorm, auxnorm, dynamic)\n\nConstants (A, B) such that ||Lf||s ≦ A||f||s + B||f||_aux\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Some examples can be found at RigorousInvariantMeasures.jl/examples/","category":"page"},{"location":"userguide/#Userguide","page":"General usage","title":"Userguide","text":"","category":"section"},{"location":"userguide/","page":"General usage","title":"General usage","text":"The main objects involved in the approximation are the following:","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"A dynamic object\nA basis object ","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"julia> using RigorousInvariantMeasures\n\njulia> D0 = mod1_dynamic(x->4*x+0.5*x*(1-x), full_branch = true)\nPiecewise-defined dynamic with 4 branches\n\njulia> D = D0∘D0∘D0\nRigorousInvariantMeasures.ComposedDynamic((RigorousInvariantMeasures.ComposedDynamic((Piecewise-defined dynamic with 4 branches, Piecewise-defined dynamic with 4 branches), Piecewise-defined dynamic with 16 branches), Piecewise-defined dynamic with 4 branches), Piecewise-defined dynamic with 64 branches)\n\njulia> B = Hat(1024)\nHat{LinRange{Float64, Int64}}(LinRange{Float64}(0.0, 1.0, 1025))","category":"page"},{"location":"userguide/#Building-the-discretized-operator","page":"General usage","title":"Building the discretized operator","text":"","category":"section"},{"location":"userguide/","page":"General usage","title":"General usage","text":"Once a basis is chosen we call DiscretizedOperator to compute the discretized operator.","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"Remark that a discretized operator can be of two types:","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"IntegralPreservingDiscretizedOperator\nNonIntegralPreservingDiscretizedOperator","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"The type of the discretized operator is prescribed by the basis; while an integral preserving operator is stored simply as a matrix, a non integral preserving operator is stored as a triple (L e w); the operator L corresponds to the matrix, while e w are used to guarantee that the operator Q = L + e*w preserves the integral.","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"This is fundamental in our theory, since the rigorous estimate depends on the fact that the  discretized operator preserves the space of average 0 functions.","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"julia> Q = DiscretizedOperator(B, D);","category":"page"},{"location":"userguide/#Bounding-the-norms-of-the-discretized-operator","page":"General usage","title":"Bounding the norms of the discretized operator","text":"","category":"section"},{"location":"userguide/","page":"General usage","title":"General usage","text":"To compute our rigorous error bound we need to compute rigorously upper bounds for the norms of the discretized operator restricted  Q^k_U_0 to the space of average 0 functions.","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"This is done through the use of powernormbounds","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"julia> norms = powernormbounds(B, D; Q=Q);","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"This function infers the strong and weak norm from the basis and uses a priori  and a posteriori information to estimate these norms.","category":"page"},{"location":"userguide/#Computing-the-invariant-vector-and-the-rigorous-error","page":"General usage","title":"Computing the invariant vector and the rigorous error","text":"","category":"section"},{"location":"userguide/","page":"General usage","title":"General usage","text":"To compute the approximation and the error we use the functions  invariant_vector and distance_from_invariant.","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"Distance from invariant returns us an upper bound between  w and the density of the invariant a.c.i.m. with respect to the  weak norm of the basis.","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"julia> w = invariant_vector(B, Q);\n\njulia> error = distance_from_invariant(B, D, Q, w, norms);\n\njulia> error <= 0.0006\ntrue\n\njulia> weak_norm(B)\nLinf","category":"page"},{"location":"userguide/#Using-the-coarse-fine-estimates","page":"General usage","title":"Using the coarse-fine estimates","text":"","category":"section"},{"location":"userguide/","page":"General usage","title":"General usage","text":"We can use now the coarse fine bounds to bound the norm of the powers of a finer discretization.","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"The function finepowernormbounds uses the computed norms  from the coarse discretization, the coefficients of the Doeblin-Fortet-Lasota-Yorke inequality and a computed error bound on the norm of Q_f. ","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"We first define a finer basis and compute the operator","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"julia> B_fine = Hat(16384);\n\njulia> Q_fine = DiscretizedOperator(B_fine, D);","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"Then, we call the coarse fine routines","category":"page"},{"location":"userguide/","page":"General usage","title":"General usage","text":"julia> normQ_fine = opnormbound(B_fine, weak_norm(B_fine), Q_fine);\n\njulia> normQ_fine ≈ 1.0433672\ntrue\n\njulia> norms_fine = finepowernormbounds(B, B_fine, D, norms; normQ_fine=normQ_fine);\n\njulia> w_fine = invariant_vector(B_fine, Q_fine);\n     \njulia> error_fine = distance_from_invariant(B_fine, D, Q_fine, w_fine, norms_fine);\n\njulia> error_fine <= 8e-5\ntrue","category":"page"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"#RigorousInvariantMeasures.jl","page":"Home","title":"RigorousInvariantMeasures.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package which implements a implements a flexible scheme to approximate rigorously invariant measures of dynamical systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is under active development, with periodic releases.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find useful this package, please cite the paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Galatolo S., Monge M., Nisoli I., Poloni F. A general framework for the rigorous computation of invariant densities and the coarse-fine strategy [arXiv:2212.05017]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Galatolo S., Nisoli I., An elementary approach to rigorous approximation of invariant measures SIAM J. Appl Dyn Sys.13 pp. 958-985 (2014)","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RigorousInvariantMeasures is licensed under the MIT license; see LICENSE for the full license text.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RigorousInvariantMeasures.jl is a registered package, and is simply installed by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add(\"RigorousInvariantMeasures\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
